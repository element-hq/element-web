// This file was originally generated by Claude Code, which put it in src/components/views/spaces/SpaceSettingsEmotesTab.tsx
// It has been moved to src/components/views/settings/tabs/room/EmotesRoomSettingsTab.tsx and edited so it makes sense to exist as a tab for all rooms, and not just spaces.

import React, { useState, useCallback, useEffect, useRef, useContext } from "react";
import { type Room } from "matrix-js-sdk/src/matrix";
import { logger } from "matrix-js-sdk/src/logger";

import { _t } from "../../../../../languageHandler";
import AccessibleButton from "../../../elements/AccessibleButton";
import SettingsTab from "../SettingsTab";
import { SettingsSection } from "../../shared/SettingsSection";
import { mediaFromMxc } from "../../../../../customisations/Media";
import { EMOTE_EVENT_TYPE } from "../../../../../utils/space-emotes";
import MatrixClientContext from "../../../../../contexts/MatrixClientContext";
import SpaceStore from "../../../../../stores/spaces/SpaceStore";

interface EmoteInfo {
    url: string;
}

type EmoteMap = Record<string, EmoteInfo>;

function uniqueShortcode(base: string, existing: EmoteMap): string {
    // If "coolface" exists in existing (which is the list of emotes that already exists in this room or space),
    // returns "coolface-2", then "coolface-3", etc.
    if (!(base in existing)) return base;
    let n = 2;
    while (`${base}-${n}` in existing) n++;
    return `${base}-${n}`;
}

function shortcodeFromFilename(filename: string): string {
    // Derive a shortcode from a filename by stripping the extension
    // and replacing non-alphanumeric characters with hyphens.
    const name = filename.replace(/\.[^.]+$/, "");
    return name.replace(/[^a-zA-Z0-9_-]/g, "-").replace(/-+/g, "-").replace(/^-|-$/g, "");
}

interface EmoteRowProps {
    shortcode: string;
    url: string;
    canEdit: boolean;
    onDelete: (shortcode: string) => void;
    onRename: (oldShortcode: string, newShortcode: string) => void;
}

const EmoteRow: React.FC<EmoteRowProps> = ({ shortcode, url, canEdit, onDelete, onRename }) => {
    const httpUrl = mediaFromMxc(url).getSquareThumbnailHttp(32) ?? undefined;
    const [editing, setEditing] = useState(false);
    const [editValue, setEditValue] = useState(shortcode);
    const inputRef = useRef<HTMLInputElement>(null);

    useEffect(() => {
        if (editing && inputRef.current) {
            inputRef.current.focus();
            inputRef.current.select();
        }
    }, [editing]);

    const commitRename = useCallback(() => {
        setEditing(false);
        const trimmed = editValue.trim();
        if (trimmed && trimmed !== shortcode) {
            onRename(shortcode, trimmed);
        } else {
            setEditValue(shortcode);
        }
    }, [editValue, shortcode, onRename]);

    const onKeyDown = useCallback(
        (e: React.KeyboardEvent) => {
            if (e.key === "Enter") {
                commitRename();
            } else if (e.key === "Escape") {
                setEditValue(shortcode);
                setEditing(false);
            }
        },
        [commitRename, shortcode],
    );

    return (
        <div className="mx_EmotesRoomSettingsTab_emoteRow">
            <img
                className="mx_EmotesRoomSettingsTab_emoteImage"
                src={httpUrl}
                alt={shortcode}
                width={32}
                height={32}
            />
            {editing ? (
                <span className="mx_EmotesRoomSettingsTab_shortcode mx_EmotesRoomSettingsTab_shortcode_editing">:<input
                    ref={inputRef}
                    type="text"
                    value={editValue}
                    onChange={(e) => setEditValue(e.target.value.replace(/[^a-zA-Z0-9_-]/g, ""))}
                    onBlur={commitRename}
                    onKeyDown={onKeyDown}
                    className="mx_EmotesRoomSettingsTab_shortcodeEditInput"
                />:</span>
            ) : (
                <span
                    className={`mx_EmotesRoomSettingsTab_shortcode ${canEdit ? "mx_EmotesRoomSettingsTab_shortcode_editable" : ""}`}
                    onClick={canEdit ? () => setEditing(true) : undefined}
                    title={canEdit ? _t("action|click_to_rename") : undefined}
                >
                    :{shortcode}:
                </span>
            )}
            {canEdit && (
                <AccessibleButton
                    kind="danger_outline"
                    onClick={() => onDelete(shortcode)}
                    className="mx_EmotesRoomSettingsTab_deleteButton"
                >
                    {_t("action|delete")}
                </AccessibleButton>
            )}
        </div>
    );
};

interface IProps {
    room: Room;
}

const EmotesRoomSettingsTab: React.FC<IProps> = ({ room }) => {
    const cli = useContext(MatrixClientContext);
    const userId = cli.getUserId()!;
    const canEdit = room.currentState.maySendStateEvent(EMOTE_EVENT_TYPE, userId);
    const isSpace = room.isSpaceRoom();
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [uploading, setUploading] = useState(false);
    const [pulling, setPulling] = useState(false);

    const [emotes, setEmotes] = useState<EmoteMap>(() => {
        const event = room.currentState.getStateEvents(EMOTE_EVENT_TYPE, "");
        return (event?.getContent()?.images as EmoteMap) ?? {};
    });

    useEffect(() => {
        const onStateEvent = (): void => {
            const event = room.currentState.getStateEvents(EMOTE_EVENT_TYPE, "");
            setEmotes((event?.getContent()?.images as EmoteMap) ?? {});
        };
        room.on("RoomState.events" as any, onStateEvent);
        return () => {
            room.off("RoomState.events" as any, onStateEvent);
        };
    }, [room]);

    const onAddEmoteClick = useCallback(() => {
        fileInputRef.current?.click();
    }, []);

    const onFileSelected = useCallback(
        async (e: React.ChangeEvent<HTMLInputElement>) => {
            const file = e.target.files?.[0];
            if (!file) return;

            e.target.value = "";

            const baseShortcode = shortcodeFromFilename(file.name);
            if (!baseShortcode) return;

            const shortcode = uniqueShortcode(baseShortcode, emotes);

            setUploading(true);
            try {
                const { content_uri: mxcUrl } = await cli.uploadContent(file);
                const newImages = { ...emotes, [shortcode]: { url: mxcUrl } };
                await cli.sendStateEvent(room.roomId, EMOTE_EVENT_TYPE as any, { images: newImages }, "");
                setEmotes(newImages);
            } catch (e) {
                logger.error("Failed to add emote:", e);
            } finally {
                setUploading(false);
            }
        },
        [cli, room.roomId, emotes],
    );

    const onDeleteEmote = useCallback(
        async (shortcode: string) => {
            try {
                const newImages = { ...emotes };
                delete newImages[shortcode];
                await cli.sendStateEvent(room.roomId, EMOTE_EVENT_TYPE as any, { images: newImages }, "");
                setEmotes(newImages);
            } catch (e) {
                logger.error("Failed to delete emote:", e);
            }
        },
        [cli, room.roomId, emotes],
    );

    const onRenameEmote = useCallback(
        async (oldShortcode: string, newShortcode: string) => {
            if (oldShortcode === newShortcode) return;
            const finalShortcode = uniqueShortcode(newShortcode, emotes);
            try {
                const newImages = { ...emotes };
                const info = newImages[oldShortcode];
                delete newImages[oldShortcode];
                newImages[finalShortcode] = info;
                await cli.sendStateEvent(room.roomId, EMOTE_EVENT_TYPE as any, { images: newImages }, "");
                setEmotes(newImages);
            } catch (e) {
                logger.error("Failed to rename emote:", e);
            }
        },
        [cli, room.roomId, emotes],
    );

    const onPullFromRooms = useCallback(async () => {
        // This should only be usable if viewing the settings for a space (so if isSpace is true)
        // and should pull emotes from every room in a space and add them as emotes to the space itself.
        setPulling(true);
        try {
            const childRooms = SpaceStore.instance.getChildRooms(room.roomId);
            let merged = { ...emotes };
            let changed = false;
            for (const childRoom of childRooms) {
                const event = childRoom.currentState.getStateEvents(EMOTE_EVENT_TYPE, "");
                const images = event?.getContent()?.images;
                if (images && typeof images === "object") {
                    for (const [shortcode, info] of Object.entries(images)) {
                        if (info && typeof info === "object" && "url" in info && typeof (info as any).url === "string") {
                            // Check if this exact emote (same shortcode + url) already exists
                            if (merged[shortcode]?.url === (info as any).url) continue;
                            const finalCode = uniqueShortcode(shortcode, merged);
                            merged[finalCode] = { url: (info as any).url };
                            changed = true;
                        }
                    }
                }
            }
            if (changed) {
                await cli.sendStateEvent(room.roomId, EMOTE_EVENT_TYPE as any, { images: merged }, "");
                setEmotes(merged);
            }
        } catch (e) {
            logger.error("Failed to pull emotes from rooms:", e);
        } finally {
            setPulling(false);
        }
    }, [cli, room.roomId, emotes]);

    const shortcodes = Object.keys(emotes);
    const description = isSpace ? _t("custom_emotes|description") : _t("custom_emotes|room_description");

    return (
        <SettingsTab>
            <SettingsSection heading={_t("custom_emotes|title")}>
                <div className="mx_EmotesRoomSettingsTab_description">
                    {description}
                </div>

                <div className="mx_EmotesRoomSettingsTab_emoteList">
                    {shortcodes.length === 0 && (
                        <div className="mx_EmotesRoomSettingsTab_noEmotes">
                            {_t("custom_emotes|no_emotes")}
                        </div>
                    )}
                    {shortcodes.map((code) => (
                        <EmoteRow
                            key={code}
                            shortcode={code}
                            url={emotes[code].url}
                            canEdit={canEdit}
                            onDelete={onDeleteEmote}
                            onRename={onRenameEmote}
                        />
                    ))}
                </div>

                {canEdit && (
                    <>
                        <div className="mx_EmotesRoomSettingsTab_actions">
                            <AccessibleButton kind="primary" onClick={onAddEmoteClick} disabled={uploading}>
                                {uploading ? _t("custom_emotes|uploading") : _t("custom_emotes|add_emote")}
                            </AccessibleButton>
                            {isSpace && (
                                <AccessibleButton kind="primary_outline" onClick={onPullFromRooms} disabled={pulling}>
                                    {pulling ? _t("custom_emotes|pulling") : _t("custom_emotes|pull_from_rooms")}
                                </AccessibleButton>
                            )}
                        </div>
                        <input
                            ref={fileInputRef}
                            type="file"
                            accept="image/*"
                            onChange={onFileSelected}
                            className="mx_EmotesRoomSettingsTab_fileInput"
                        />
                    </>
                )}
            </SettingsSection>
        </SettingsTab>
    );
};

export default EmotesRoomSettingsTab;
