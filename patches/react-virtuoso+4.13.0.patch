diff --git a/node_modules/react-virtuoso/dist/index.d.ts b/node_modules/react-virtuoso/dist/index.d.ts
index 02aa371..0a0b032 100644
--- a/node_modules/react-virtuoso/dist/index.d.ts
+++ b/node_modules/react-virtuoso/dist/index.d.ts
@@ -384,6 +384,12 @@ export declare type ScrollIntoViewLocation = FlatScrollIntoViewLocation | Groupe
 export declare interface ScrollIntoViewLocationOptions {
     align?: 'center' | 'end' | 'start';
     behavior?: 'auto' | 'smooth';
+    /**
+     * Use this function for the scroll to be initiated directly after the next update of data/totalCount.
+     * The index provided therefore should be consistent with the data/totalCount set.
+     * It is only currently designed to be used with behavior: 'auto'.
+     */
+    targetsNextRefresh?: boolean;
     /**
      * Use this function to fine-tune the scrollIntoView behavior.
      * The function receives the item's top and bottom position in the viewport, and the viewport top/bottom.
diff --git a/node_modules/react-virtuoso/dist/index.mjs b/node_modules/react-virtuoso/dist/index.mjs
index 2fc85b5..1a442cb 100644
--- a/node_modules/react-virtuoso/dist/index.mjs
+++ b/node_modules/react-virtuoso/dist/index.mjs
@@ -1,14 +1,14 @@
-import { jsx as z, jsxs as Nt, Fragment as lo } from "react/jsx-runtime";
-import H, { createElement as _t } from "react";
+import { jsx as V, jsxs as _t, Fragment as lo } from "react/jsx-runtime";
+import E, { createElement as Gt } from "react";
 import co from "react-dom";
-const we = 0, zt = 1, qt = 2, kn = 4;
+const Ce = 0, zt = 1, jt = 2, kn = 4;
 function cn(t) {
   return () => t;
 }
 function uo(t) {
   t();
 }
-function ne(t, e) {
+function te(t, e) {
   return (n) => t(e(n));
 }
 function un(t, e) {
@@ -25,33 +25,33 @@ function fo(...t) {
     t.map(uo);
   };
 }
-function Yt() {
+function qt() {
 }
-function ve(t, e) {
+function we(t, e) {
   return e(t), t;
 }
 function mo(t, e) {
   return e(t);
 }
-function X(...t) {
+function Q(...t) {
   return t;
 }
-function K(t, e) {
+function j(t, e) {
   return t(zt, e);
 }
 function G(t, e) {
-  t(we, e);
+  t(Ce, e);
 }
 function We(t) {
-  t(qt);
+  t(jt);
 }
-function st(t) {
+function lt(t) {
   return t(kn);
 }
 function O(t, e) {
-  return K(t, ao(e, we));
+  return j(t, ao(e, Ce));
 }
-function bt(t, e) {
+function vt(t, e) {
   const n = t(zt, (o) => {
     n(), e(o);
   });
@@ -68,43 +68,43 @@ function an(t) {
 function Fn(t, e) {
   return t === e;
 }
-function Z(t = Fn) {
+function J(t = Fn) {
   let e;
   return (n) => (o) => {
     t(e, o) || (e = o, n(o));
   };
 }
-function P(t) {
+function A(t) {
   return (e) => (n) => {
     t(n) && e(n);
   };
 }
-function E(t) {
-  return (e) => ne(e, t);
+function B(t) {
+  return (e) => te(e, t);
 }
-function yt(t) {
+function bt(t) {
   return (e) => () => {
     e(t);
   };
 }
-function x(t, ...e) {
+function T(t, ...e) {
   const n = po(...e);
   return (o, r) => {
     switch (o) {
-      case qt:
+      case jt:
         We(t);
         return;
       case zt:
-        return K(t, n(r));
+        return j(t, n(r));
     }
   };
 }
-function Rt(t, e) {
+function Ht(t, e) {
   return (n) => (o) => {
     n(e = t(e, o));
   };
 }
-function jt(t) {
+function Kt(t) {
   return (e) => (n) => {
     t > 0 ? t-- : e(n);
   };
@@ -123,9 +123,9 @@ function _(...t) {
   const r = Math.pow(2, t.length) - 1;
   return t.forEach((s, i) => {
     const l = Math.pow(2, i);
-    K(s, (c) => {
-      const a = n;
-      n = n | l, e[i] = c, a !== r && n === r && o && (o(), o = null);
+    j(s, (c) => {
+      const u = n;
+      n = n | l, e[i] = c, u !== r && n === r && o && (o(), o = null);
     });
   }), (s) => (i) => {
     const l = () => {
@@ -143,8 +143,8 @@ function ho(t) {
   return function(r, s) {
     switch (r) {
       case zt:
-        return s ? n === s ? void 0 : (o(), n = s, e = K(t, s), e) : (o(), Yt);
-      case qt:
+        return s ? n === s ? void 0 : (o(), n = s, e = j(t, s), e) : (o(), qt);
+      case jt:
         o(), n = null;
         return;
     }
@@ -152,10 +152,10 @@ function ho(t) {
 }
 function C(t) {
   let e = t;
-  const n = $();
+  const n = D();
   return (o, r) => {
     switch (o) {
-      case we:
+      case Ce:
         e = r;
         break;
       case zt: {
@@ -168,19 +168,19 @@ function C(t) {
     return n(o, r);
   };
 }
-function ct(t, e) {
-  return ve(C(e), (n) => O(t, n));
+function at(t, e) {
+  return we(C(e), (n) => O(t, n));
 }
-function $() {
+function D() {
   const t = [];
   return (e, n) => {
     switch (e) {
-      case we:
+      case Ce:
         t.slice().forEach((o) => {
           o(n);
         });
         return;
-      case qt:
+      case jt:
         t.splice(0, t.length);
         return;
       case zt:
@@ -191,10 +191,10 @@ function $() {
     }
   };
 }
-function ht(t) {
-  return ve($(), (e) => O(t, e));
+function gt(t) {
+  return we(D(), (e) => O(t, e));
 }
-function U(t, e = [], { singleton: n } = { singleton: !0 }) {
+function $(t, e = [], { singleton: n } = { singleton: !0 }) {
   return {
     constructor: t,
     dependencies: e,
@@ -212,46 +212,46 @@ function Io(t) {
   };
   return n(t);
 }
-function rt(...t) {
-  const e = $(), n = new Array(t.length);
+function st(...t) {
+  const e = D(), n = new Array(t.length);
   let o = 0;
   const r = Math.pow(2, t.length) - 1;
   return t.forEach((s, i) => {
     const l = Math.pow(2, i);
-    K(s, (c) => {
+    j(s, (c) => {
       n[i] = c, o = o | l, o === r && G(e, n);
     });
   }), function(s, i) {
     switch (s) {
-      case qt: {
+      case jt: {
         We(e);
         return;
       }
       case zt:
-        return o === r && i(n), K(e, i);
+        return o === r && i(n), j(e, i);
     }
   };
 }
-function A(t, e = Fn) {
-  return x(t, Z(e));
+function P(t, e = Fn) {
+  return T(t, J(e));
 }
 function dn(...t) {
   return function(e, n) {
     switch (e) {
-      case qt:
+      case jt:
         return;
       case zt:
-        return fo(...t.map((o) => K(o, n)));
+        return fo(...t.map((o) => j(o, n)));
     }
   };
 }
-var mt = /* @__PURE__ */ ((t) => (t[t.DEBUG = 0] = "DEBUG", t[t.INFO = 1] = "INFO", t[t.WARN = 2] = "WARN", t[t.ERROR = 3] = "ERROR", t))(mt || {});
+var pt = /* @__PURE__ */ ((t) => (t[t.DEBUG = 0] = "DEBUG", t[t.INFO = 1] = "INFO", t[t.WARN = 2] = "WARN", t[t.ERROR = 3] = "ERROR", t))(pt || {});
 const So = {
   0: "debug",
   3: "error",
   1: "log",
   2: "warn"
-}, xo = () => typeof globalThis > "u" ? window : globalThis, Vt = U(
+}, xo = () => typeof globalThis > "u" ? window : globalThis, Vt = $(
   () => {
     const t = C(
       3
@@ -260,7 +260,7 @@ const So = {
     return {
       log: C((n, o, r = 1) => {
         var i;
-        const s = (i = xo().VIRTUOSO_LOG_LEVEL) != null ? i : st(t);
+        const s = (i = xo().VIRTUOSO_LOG_LEVEL) != null ? i : lt(t);
         r >= s && console[So[r]](
           "%creact-virtuoso: %c%s %o",
           "color: #0253b3; font-weight: bold",
@@ -275,14 +275,14 @@ const So = {
   [],
   { singleton: !0 }
 );
-function Ht(t, e, n) {
+function Et(t, e, n) {
   return Ge(t, e, n).callbackRef;
 }
 function Ge(t, e, n) {
-  const o = H.useRef(null);
+  const o = E.useRef(null);
   let r = (i) => {
   };
-  const s = H.useMemo(() => typeof ResizeObserver < "u" ? new ResizeObserver((i) => {
+  const s = E.useMemo(() => typeof ResizeObserver < "u" ? new ResizeObserver((i) => {
     const l = () => {
       const c = i[0].target;
       c.offsetParent !== null && t(c);
@@ -294,27 +294,27 @@ function Ge(t, e, n) {
   }, { callbackRef: r, ref: o };
 }
 function On(t, e, n, o, r, s, i, l, c) {
-  const a = H.useCallback(
-    (p) => {
-      const S = To(p.children, e, l ? "offsetWidth" : "offsetHeight", r);
-      let g = p.parentElement;
-      for (; !g.dataset.virtuosoScroller; )
-        g = g.parentElement;
-      const h = g.lastElementChild.dataset.viewportType === "window";
+  const u = E.useCallback(
+    (m) => {
+      const I = To(m.children, e, l ? "offsetWidth" : "offsetHeight", r);
+      let h = m.parentElement;
+      for (; !h.dataset.virtuosoScroller; )
+        h = h.parentElement;
+      const p = h.lastElementChild.dataset.viewportType === "window";
       let w;
-      h && (w = g.ownerDocument.defaultView);
-      const v = i ? l ? i.scrollLeft : i.scrollTop : h ? l ? w.scrollX || w.document.documentElement.scrollLeft : w.scrollY || w.document.documentElement.scrollTop : l ? g.scrollLeft : g.scrollTop, m = i ? l ? i.scrollWidth : i.scrollHeight : h ? l ? w.document.documentElement.scrollWidth : w.document.documentElement.scrollHeight : l ? g.scrollWidth : g.scrollHeight, d = i ? l ? i.offsetWidth : i.offsetHeight : h ? l ? w.innerWidth : w.innerHeight : l ? g.offsetWidth : g.offsetHeight;
+      p && (w = h.ownerDocument.defaultView);
+      const y = i ? l ? i.scrollLeft : i.scrollTop : p ? l ? w.scrollX || w.document.documentElement.scrollLeft : w.scrollY || w.document.documentElement.scrollTop : l ? h.scrollLeft : h.scrollTop, f = i ? l ? i.scrollWidth : i.scrollHeight : p ? l ? w.document.documentElement.scrollWidth : w.document.documentElement.scrollHeight : l ? h.scrollWidth : h.scrollHeight, d = i ? l ? i.offsetWidth : i.offsetHeight : p ? l ? w.innerWidth : w.innerHeight : l ? h.offsetWidth : h.offsetHeight;
       o({
-        scrollHeight: m,
-        scrollTop: Math.max(v, 0),
+        scrollHeight: f,
+        scrollTop: Math.max(y, 0),
         viewportHeight: d
       }), s == null || s(
-        l ? fn("column-gap", getComputedStyle(p).columnGap, r) : fn("row-gap", getComputedStyle(p).rowGap, r)
-      ), S !== null && t(S);
+        l ? fn("column-gap", getComputedStyle(m).columnGap, r) : fn("row-gap", getComputedStyle(m).rowGap, r)
+      ), I !== null && t(I);
     },
     [t, e, r, s, i, o, l]
   );
-  return Ge(a, n, c);
+  return Ge(u, n, c);
 }
 function To(t, e, n, o) {
   const r = t.length;
@@ -325,91 +325,91 @@ function To(t, e, n, o) {
     const l = t.item(i);
     if (l.dataset.index === void 0)
       continue;
-    const c = parseInt(l.dataset.index), a = parseFloat(l.dataset.knownSize), p = e(l, n);
-    if (p === 0 && o("Zero-sized element, this should not happen", { child: l }, mt.ERROR), p === a)
+    const c = parseInt(l.dataset.index), u = parseFloat(l.dataset.knownSize), m = e(l, n);
+    if (m === 0 && o("Zero-sized element, this should not happen", { child: l }, pt.ERROR), m === u)
       continue;
-    const S = s[s.length - 1];
-    s.length === 0 || S.size !== p || S.endIndex !== c - 1 ? s.push({ endIndex: c, size: p, startIndex: c }) : s[s.length - 1].endIndex++;
+    const I = s[s.length - 1];
+    s.length === 0 || I.size !== m || I.endIndex !== c - 1 ? s.push({ endIndex: c, size: m, startIndex: c }) : s[s.length - 1].endIndex++;
   }
   return s;
 }
 function fn(t, e, n) {
-  return e !== "normal" && !(e != null && e.endsWith("px")) && n(`${t} was not resolved to pixel value correctly`, e, mt.WARN), e === "normal" ? 0 : parseInt(e != null ? e : "0", 10);
+  return e !== "normal" && !(e != null && e.endsWith("px")) && n(`${t} was not resolved to pixel value correctly`, e, pt.WARN), e === "normal" ? 0 : parseInt(e != null ? e : "0", 10);
 }
 function _e(t, e, n) {
-  const o = H.useRef(null), r = H.useCallback(
+  const o = E.useRef(null), r = E.useCallback(
     (c) => {
       if (!(c != null && c.offsetParent))
         return;
-      const a = c.getBoundingClientRect(), p = a.width;
-      let S, g;
+      const u = c.getBoundingClientRect(), m = u.width;
+      let I, h;
       if (e) {
-        const h = e.getBoundingClientRect(), w = a.top - h.top;
-        g = h.height - Math.max(0, w), S = w + e.scrollTop;
+        const p = e.getBoundingClientRect(), w = u.top - p.top;
+        h = p.height - Math.max(0, w), I = w + e.scrollTop;
       } else {
-        const h = i.current.ownerDocument.defaultView;
-        g = h.innerHeight - Math.max(0, a.top), S = a.top + h.scrollY;
+        const p = i.current.ownerDocument.defaultView;
+        h = p.innerHeight - Math.max(0, u.top), I = u.top + p.scrollY;
       }
       o.current = {
-        offsetTop: S,
-        visibleHeight: g,
-        visibleWidth: p
+        offsetTop: I,
+        visibleHeight: h,
+        visibleWidth: m
       }, t(o.current);
     },
     // eslint-disable-next-line react-hooks/exhaustive-deps
     [t, e]
-  ), { callbackRef: s, ref: i } = Ge(r, !0, n), l = H.useCallback(() => {
+  ), { callbackRef: s, ref: i } = Ge(r, !0, n), l = E.useCallback(() => {
     r(i.current);
   }, [r, i]);
-  return H.useEffect(() => {
+  return E.useEffect(() => {
     var c;
     if (e) {
       e.addEventListener("scroll", l);
-      const a = new ResizeObserver(() => {
+      const u = new ResizeObserver(() => {
         requestAnimationFrame(l);
       });
-      return a.observe(e), () => {
-        e.removeEventListener("scroll", l), a.unobserve(e);
+      return u.observe(e), () => {
+        e.removeEventListener("scroll", l), u.unobserve(e);
       };
     } else {
-      const a = (c = i.current) == null ? void 0 : c.ownerDocument.defaultView;
-      return a == null || a.addEventListener("scroll", l), a == null || a.addEventListener("resize", l), () => {
-        a == null || a.removeEventListener("scroll", l), a == null || a.removeEventListener("resize", l);
+      const u = (c = i.current) == null ? void 0 : c.ownerDocument.defaultView;
+      return u == null || u.addEventListener("scroll", l), u == null || u.addEventListener("resize", l), () => {
+        u == null || u.removeEventListener("scroll", l), u == null || u.removeEventListener("resize", l);
       };
     }
   }, [l, e, i]), s;
 }
-const at = U(
+const dt = $(
   () => {
-    const t = $(), e = $(), n = C(0), o = $(), r = C(0), s = $(), i = $(), l = C(0), c = C(0), a = C(0), p = C(0), S = $(), g = $(), h = C(!1), w = C(!1), v = C(!1);
+    const t = D(), e = D(), n = C(0), o = D(), r = C(0), s = D(), i = D(), l = C(0), c = C(0), u = C(0), m = C(0), I = D(), h = D(), p = C(!1), w = C(!1), y = C(!1);
     return O(
-      x(
+      T(
         t,
-        E(({ scrollTop: m }) => m)
+        B(({ scrollTop: f }) => f)
       ),
       e
     ), O(
-      x(
+      T(
         t,
-        E(({ scrollHeight: m }) => m)
+        B(({ scrollHeight: f }) => f)
       ),
       i
     ), O(e, r), {
       deviation: n,
-      fixedFooterHeight: a,
+      fixedFooterHeight: u,
       fixedHeaderHeight: c,
-      footerHeight: p,
+      footerHeight: m,
       headerHeight: l,
       horizontalDirection: w,
-      scrollBy: g,
+      scrollBy: h,
       // input
       scrollContainerState: t,
       scrollHeight: i,
-      scrollingInProgress: h,
+      scrollingInProgress: p,
       // signals
-      scrollTo: S,
+      scrollTo: I,
       scrollTop: e,
-      skipAnimationFrameInResizeObserver: v,
+      skipAnimationFrameInResizeObserver: y,
       smoothScrollTargetReached: o,
       // state
       statefulScrollTop: r,
@@ -418,7 +418,7 @@ const at = U(
   },
   [],
   { singleton: !0 }
-), oe = { lvl: 0 };
+), ee = { lvl: 0 };
 function Ln(t, e) {
   const n = t.length;
   if (n === 0)
@@ -431,72 +431,72 @@ function Ln(t, e) {
   }
   return s.push({ end: 1 / 0, start: o, value: r }), s;
 }
-function j(t) {
-  return t === oe;
+function Y(t) {
+  return t === ee;
 }
-function re(t, e) {
-  if (!j(t))
-    return e === t.k ? t.v : e < t.k ? re(t.l, e) : re(t.r, e);
+function ne(t, e) {
+  if (!Y(t))
+    return e === t.k ? t.v : e < t.k ? ne(t.l, e) : ne(t.r, e);
 }
-function Ct(t, e, n = "k") {
-  if (j(t))
+function yt(t, e, n = "k") {
+  if (Y(t))
     return [-1 / 0, void 0];
   if (Number(t[n]) === e)
     return [t.k, t.v];
   if (Number(t[n]) < e) {
-    const o = Ct(t.r, e, n);
+    const o = yt(t.r, e, n);
     return o[0] === -1 / 0 ? [t.k, t.v] : o;
   }
-  return Ct(t.l, e, n);
+  return yt(t.l, e, n);
 }
-function pt(t, e, n) {
-  return j(t) ? Pn(e, n, 1) : e === t.k ? ot(t, { k: e, v: n }) : e < t.k ? mn(ot(t, { l: pt(t.l, e, n) })) : mn(ot(t, { r: pt(t.r, e, n) }));
+function ht(t, e, n) {
+  return Y(t) ? Pn(e, n, 1) : e === t.k ? rt(t, { k: e, v: n }) : e < t.k ? mn(rt(t, { l: ht(t.l, e, n) })) : mn(rt(t, { r: ht(t.r, e, n) }));
 }
-function Kt() {
-  return oe;
+function Ut() {
+  return ee;
 }
-function ye(t, e, n) {
-  if (j(t))
+function ve(t, e, n) {
+  if (Y(t))
     return [];
-  const o = Ct(t, e)[0];
+  const o = yt(t, e)[0];
   return Co(ze(t, o, n));
 }
 function Le(t, e) {
-  if (j(t)) return oe;
+  if (Y(t)) return ee;
   const { k: n, l: o, r } = t;
   if (e === n) {
-    if (j(o))
+    if (Y(o))
       return r;
-    if (j(r))
+    if (Y(r))
       return o;
     {
       const [s, i] = Vn(o);
-      return ge(ot(t, { k: s, l: zn(o), v: i }));
+      return he(rt(t, { k: s, l: zn(o), v: i }));
     }
-  } else return e < n ? ge(ot(t, { l: Le(o, e) })) : ge(ot(t, { r: Le(r, e) }));
+  } else return e < n ? he(rt(t, { l: Le(o, e) })) : he(rt(t, { r: Le(r, e) }));
 }
-function Gt(t) {
-  return j(t) ? [] : [...Gt(t.l), { k: t.k, v: t.v }, ...Gt(t.r)];
+function Wt(t) {
+  return Y(t) ? [] : [...Wt(t.l), { k: t.k, v: t.v }, ...Wt(t.r)];
 }
 function ze(t, e, n) {
-  if (j(t))
+  if (Y(t))
     return [];
   const { k: o, l: r, r: s, v: i } = t;
   let l = [];
   return o > e && (l = l.concat(ze(r, e, n))), o >= e && o <= n && l.push({ k: o, v: i }), o <= n && (l = l.concat(ze(s, e, n))), l;
 }
-function ge(t) {
+function he(t) {
   const { l: e, lvl: n, r: o } = t;
   if (o.lvl >= n - 1 && e.lvl >= n - 1)
     return t;
   if (n > o.lvl + 1) {
     if (Ee(e))
-      return An(ot(t, { lvl: n - 1 }));
-    if (!j(e) && !j(e.r))
-      return ot(e.r, {
-        l: ot(e, { r: e.r.l }),
+      return An(rt(t, { lvl: n - 1 }));
+    if (!Y(e) && !Y(e.r))
+      return rt(e.r, {
+        l: rt(e, { r: e.r.l }),
         lvl: n,
-        r: ot(t, {
+        r: rt(t, {
           l: e.r.r,
           lvl: n - 1
         })
@@ -504,22 +504,22 @@ function ge(t) {
     throw new Error("Unexpected empty nodes");
   } else {
     if (Ee(t))
-      return Ve(ot(t, { lvl: n - 1 }));
-    if (!j(o) && !j(o.l)) {
+      return Ve(rt(t, { lvl: n - 1 }));
+    if (!Y(o) && !Y(o.l)) {
       const r = o.l, s = Ee(r) ? o.lvl - 1 : o.lvl;
-      return ot(r, {
-        l: ot(t, {
+      return rt(r, {
+        l: rt(t, {
           lvl: n - 1,
           r: r.l
         }),
         lvl: r.lvl + 1,
-        r: Ve(ot(o, { l: r.r, lvl: s }))
+        r: Ve(rt(o, { l: r.r, lvl: s }))
       });
     } else
       throw new Error("Unexpected empty nodes");
   }
 }
-function ot(t, e) {
+function rt(t, e) {
   return Pn(
     e.k !== void 0 ? e.k : t.k,
     e.v !== void 0 ? e.v : t.v,
@@ -529,15 +529,15 @@ function ot(t, e) {
   );
 }
 function zn(t) {
-  return j(t.r) ? t.l : ge(ot(t, { r: zn(t.r) }));
+  return Y(t.r) ? t.l : he(rt(t, { r: zn(t.r) }));
 }
 function Ee(t) {
-  return j(t) || t.lvl > t.r.lvl;
+  return Y(t) || t.lvl > t.r.lvl;
 }
 function Vn(t) {
-  return j(t.r) ? [t.k, t.v] : Vn(t.r);
+  return Y(t.r) ? [t.k, t.v] : Vn(t.r);
 }
-function Pn(t, e, n, o = oe, r = oe) {
+function Pn(t, e, n, o = ee, r = ee) {
   return { k: t, l: o, lvl: n, r, v: e };
 }
 function mn(t) {
@@ -545,11 +545,11 @@ function mn(t) {
 }
 function An(t) {
   const { l: e } = t;
-  return !j(e) && e.lvl === t.lvl ? ot(e, { r: ot(t, { l: e.r }) }) : t;
+  return !Y(e) && e.lvl === t.lvl ? rt(e, { r: rt(t, { l: e.r }) }) : t;
 }
 function Ve(t) {
   const { lvl: e, r: n } = t;
-  return !j(n) && !j(n.r) && n.lvl === e && n.r.lvl === e ? ot(n, { l: ot(t, { r: n.l }), lvl: e + 1 }) : t;
+  return !Y(n) && !Y(n.r) && n.lvl === e && n.r.lvl === e ? rt(n, { l: rt(t, { r: n.l }), lvl: e + 1 }) : t;
 }
 function Co(t) {
   return Ln(t, ({ k: e, v: n }) => ({ index: e, value: n }));
@@ -557,18 +557,18 @@ function Co(t) {
 function Mn(t, e) {
   return !!(t && t.startIndex === e.startIndex && t.endIndex === e.endIndex);
 }
-function se(t, e) {
+function oe(t, e) {
   return !!(t && t[0] === e[0] && t[1] === e[1]);
 }
-const Ne = U(
+const Ne = $(
   () => ({ recalcInProgress: C(!1) }),
   [],
   { singleton: !0 }
 );
 function Wn(t, e, n) {
-  return t[Se(t, e, n)];
+  return t[Ie(t, e, n)];
 }
-function Se(t, e, n, o = 0) {
+function Ie(t, e, n, o = 0) {
   let r = t.length - 1;
   for (; o <= r; ) {
     const s = Math.floor((o + r) / 2), i = t[s], l = n(i, e);
@@ -587,14 +587,14 @@ function Se(t, e, n, o = 0) {
   throw new Error(`Failed binary finding record in array - ${t.join(",")}, searched for ${e}`);
 }
 function wo(t, e, n, o) {
-  const r = Se(t, e, o), s = Se(t, n, o, r);
+  const r = Ie(t, e, o), s = Ie(t, n, o, r);
   return t.slice(r, s + 1);
 }
-function wt(t, e) {
+function Rt(t, e) {
   return Math.round(t.getBoundingClientRect()[e]);
 }
-function Re(t) {
-  return !j(t.groupOffsetTree);
+function ye(t) {
+  return !Y(t.groupOffsetTree);
 }
 function De({ index: t }, e) {
   return e === t ? 0 : e < t ? -1 : 1;
@@ -602,29 +602,29 @@ function De({ index: t }, e) {
 function vo() {
   return {
     groupIndices: [],
-    groupOffsetTree: Kt(),
+    groupOffsetTree: Ut(),
     lastIndex: 0,
     lastOffset: 0,
     lastSize: 0,
     offsetTree: [],
-    sizeTree: Kt()
+    sizeTree: Ut()
   };
 }
 function yo(t, e) {
-  let n = j(t) ? 0 : 1 / 0;
+  let n = Y(t) ? 0 : 1 / 0;
   for (const o of e) {
     const { endIndex: r, size: s, startIndex: i } = o;
-    if (n = Math.min(n, i), j(t)) {
-      t = pt(t, 0, s);
+    if (n = Math.min(n, i), Y(t)) {
+      t = ht(t, 0, s);
       continue;
     }
-    const l = ye(t, i - 1, r + 1);
+    const l = ve(t, i - 1, r + 1);
     if (l.some(Fo(o)))
       continue;
-    let c = !1, a = !1;
-    for (const { end: p, start: S, value: g } of l)
-      c ? (r >= S || s === g) && (t = Le(t, S)) : (a = g !== s, c = !0), p > r && r >= S && g !== s && (t = pt(t, r + 1, g));
-    a && (t = pt(t, i, s));
+    let c = !1, u = !1;
+    for (const { end: m, start: I, value: h } of l)
+      c ? (r >= I || s === h) && (t = Le(t, I)) : (u = h !== s, c = !0), m > r && r >= I && h !== s && (t = ht(t, r + 1, h));
+    u && (t = ht(t, i, s));
   }
   return [t, n];
 }
@@ -634,14 +634,14 @@ function Ro(t) {
 function bo({ offset: t }, e) {
   return e === t ? 0 : e < t ? -1 : 1;
 }
-function ie(t, e, n) {
+function re(t, e, n) {
   if (e.length === 0)
     return 0;
   const { index: o, offset: r, size: s } = Wn(e, t, De), i = t - o, l = s * i + (i - 1) * n + r;
   return l > 0 ? l + n : l;
 }
 function Gn(t, e) {
-  if (!Re(e))
+  if (!ye(e))
     return t;
   let n = 0;
   for (; e.groupIndices[n] <= t + n; )
@@ -661,29 +661,29 @@ function Ho(t, e, n, o = 0) {
   return o > 0 && (e = Math.max(e, Wn(t, o, De).offset)), Ln(wo(t, e, n, bo), ko);
 }
 function Eo(t, [e, n, o, r]) {
-  e.length > 0 && o("received item sizes", e, mt.DEBUG);
+  e.length > 0 && o("received item sizes", e, pt.DEBUG);
   const s = t.sizeTree;
   let i = s, l = 0;
-  if (n.length > 0 && j(s) && e.length === 2) {
-    const g = e[0].size, h = e[1].size;
-    i = n.reduce((w, v) => pt(pt(w, v, g), v + 1, h), i);
+  if (n.length > 0 && Y(s) && e.length === 2) {
+    const h = e[0].size, p = e[1].size;
+    i = n.reduce((w, y) => ht(ht(w, y, h), y + 1, p), i);
   } else
     [i, l] = yo(i, e);
   if (i === s)
     return t;
-  const { lastIndex: c, lastOffset: a, lastSize: p, offsetTree: S } = Pe(t.offsetTree, l, i, r);
+  const { lastIndex: c, lastOffset: u, lastSize: m, offsetTree: I } = Pe(t.offsetTree, l, i, r);
   return {
     groupIndices: n,
-    groupOffsetTree: n.reduce((g, h) => pt(g, h, ie(h, S, r)), Kt()),
+    groupOffsetTree: n.reduce((h, p) => ht(h, p, re(p, I, r)), Ut()),
     lastIndex: c,
-    lastOffset: a,
-    lastSize: p,
-    offsetTree: S,
+    lastOffset: u,
+    lastSize: m,
+    offsetTree: I,
     sizeTree: i
   };
 }
 function Bo(t) {
-  return Gt(t).map(({ k: e, v: n }, o, r) => {
+  return Wt(t).map(({ k: e, v: n }, o, r) => {
     const s = r[o + 1];
     return { endIndex: s ? s.k - 1 : 1 / 0, size: n, startIndex: e };
   });
@@ -697,18 +697,18 @@ function pn(t, e) {
 function Pe(t, e, n, o) {
   let r = t, s = 0, i = 0, l = 0, c = 0;
   if (e !== 0) {
-    c = Se(r, e - 1, De), l = r[c].offset;
-    const p = Ct(n, e - 1);
-    s = p[0], i = p[1], r.length && r[c].size === Ct(n, e)[1] && (c -= 1), r = r.slice(0, c + 1);
+    c = Ie(r, e - 1, De), l = r[c].offset;
+    const m = yt(n, e - 1);
+    s = m[0], i = m[1], r.length && r[c].size === yt(n, e)[1] && (c -= 1), r = r.slice(0, c + 1);
   } else
     r = [];
-  for (const { start: a, value: p } of ye(n, e, 1 / 0)) {
-    const S = a - s, g = S * i + l + S * o;
+  for (const { start: u, value: m } of ve(n, e, 1 / 0)) {
+    const I = u - s, h = I * i + l + I * o;
     r.push({
-      index: a,
-      offset: g,
-      size: p
-    }), s = a, l = g, i = p;
+      index: u,
+      offset: h,
+      size: m
+    }), s = u, l = h, i = m;
   }
   return {
     lastIndex: s,
@@ -727,162 +727,162 @@ function Fo(t) {
 const Oo = {
   offsetHeight: "height",
   offsetWidth: "width"
-}, Et = U(
+}, Bt = $(
   ([{ log: t }, { recalcInProgress: e }]) => {
-    const n = $(), o = $(), r = ct(o, 0), s = $(), i = $(), l = C(0), c = C([]), a = C(void 0), p = C(void 0), S = C((I, f) => wt(I, Oo[f])), g = C(void 0), h = C(0), w = vo(), v = ct(
-      x(n, _(c, t, h), Rt(Eo, w), Z()),
+    const n = D(), o = D(), r = at(o, 0), s = D(), i = D(), l = C(0), c = C([]), u = C(void 0), m = C(void 0), I = C((g, v) => Rt(g, Oo[v])), h = C(void 0), p = C(0), w = vo(), y = at(
+      T(n, _(c, t, p), Ht(Eo, w), J()),
       w
-    ), m = ct(
-      x(
+    ), f = at(
+      T(
         c,
-        Z(),
-        Rt((I, f) => ({ current: f, prev: I.current }), {
+        J(),
+        Ht((g, v) => ({ current: v, prev: g.current }), {
           current: [],
           prev: []
         }),
-        E(({ prev: I }) => I)
+        B(({ prev: g }) => g)
       ),
       []
     );
     O(
-      x(
+      T(
         c,
-        P((I) => I.length > 0),
-        _(v, h),
-        E(([I, f, b]) => {
-          const k = I.reduce((F, L, V) => pt(F, L, ie(L, f.offsetTree, b) || V), Kt());
+        A((g) => g.length > 0),
+        _(y, p),
+        B(([g, v, x]) => {
+          const k = g.reduce((H, L, z) => ht(H, L, re(L, v.offsetTree, x) || z), Ut());
           return {
-            ...f,
-            groupIndices: I,
+            ...v,
+            groupIndices: g,
             groupOffsetTree: k
           };
         })
       ),
-      v
+      y
     ), O(
-      x(
+      T(
         o,
-        _(v),
-        P(([I, { lastIndex: f }]) => I < f),
-        E(([I, { lastIndex: f, lastSize: b }]) => [
+        _(y),
+        A(([g, { lastIndex: v }]) => g < v),
+        B(([g, { lastIndex: v, lastSize: x }]) => [
           {
-            endIndex: f,
-            size: b,
-            startIndex: I
+            endIndex: v,
+            size: x,
+            startIndex: g
           }
         ])
       ),
       n
-    ), O(a, p);
-    const d = ct(
-      x(
-        a,
-        E((I) => I === void 0)
+    ), O(u, m);
+    const d = at(
+      T(
+        u,
+        B((g) => g === void 0)
       ),
       !0
     );
     O(
-      x(
-        p,
-        P((I) => I !== void 0 && j(st(v).sizeTree)),
-        E((I) => [{ endIndex: 0, size: I, startIndex: 0 }])
+      T(
+        m,
+        A((g) => g !== void 0 && Y(lt(y).sizeTree)),
+        B((g) => [{ endIndex: 0, size: g, startIndex: 0 }])
       ),
       n
     );
-    const u = ht(
-      x(
+    const a = gt(
+      T(
         n,
-        _(v),
-        Rt(
-          ({ sizes: I }, [f, b]) => ({
-            changed: b !== I,
-            sizes: b
+        _(y),
+        Ht(
+          ({ sizes: g }, [v, x]) => ({
+            changed: x !== g,
+            sizes: x
           }),
           { changed: !1, sizes: w }
         ),
-        E((I) => I.changed)
+        B((g) => g.changed)
       )
     );
-    K(
-      x(
+    j(
+      T(
         l,
-        Rt(
-          (I, f) => ({ diff: I.prev - f, prev: f }),
+        Ht(
+          (g, v) => ({ diff: g.prev - v, prev: v }),
           { diff: 0, prev: 0 }
         ),
-        E((I) => I.diff)
+        B((g) => g.diff)
       ),
-      (I) => {
-        const { groupIndices: f } = st(v);
-        if (I > 0)
-          G(e, !0), G(s, I + pn(I, f));
-        else if (I < 0) {
-          const b = st(m);
-          b.length > 0 && (I -= pn(-I, b)), G(i, I);
+      (g) => {
+        const { groupIndices: v } = lt(y);
+        if (g > 0)
+          G(e, !0), G(s, g + pn(g, v));
+        else if (g < 0) {
+          const x = lt(f);
+          x.length > 0 && (g -= pn(-g, x)), G(i, g);
         }
       }
-    ), K(x(l, _(t)), ([I, f]) => {
-      I < 0 && f(
+    ), j(T(l, _(t)), ([g, v]) => {
+      g < 0 && v(
         "`firstItemIndex` prop should not be set to less than zero. If you don't know the total count, just use a very high value",
         { firstItemIndex: l },
-        mt.ERROR
+        pt.ERROR
       );
     });
-    const T = ht(s);
+    const S = gt(s);
     O(
-      x(
+      T(
         s,
-        _(v),
-        E(([I, f]) => {
-          const b = f.groupIndices.length > 0, k = [], F = f.lastSize;
-          if (b) {
-            const L = re(f.sizeTree, 0);
-            let V = 0, D = 0;
-            for (; V < I; ) {
-              const B = f.groupIndices[D], Y = f.groupIndices.length === D + 1 ? 1 / 0 : f.groupIndices[D + 1] - B - 1;
+        _(y),
+        B(([g, v]) => {
+          const x = v.groupIndices.length > 0, k = [], H = v.lastSize;
+          if (x) {
+            const L = ne(v.sizeTree, 0);
+            let z = 0, U = 0;
+            for (; z < g; ) {
+              const F = v.groupIndices[U], K = v.groupIndices.length === U + 1 ? 1 / 0 : v.groupIndices[U + 1] - F - 1;
               k.push({
-                endIndex: B,
+                endIndex: F,
                 size: L,
-                startIndex: B
+                startIndex: F
               }), k.push({
-                endIndex: B + 1 + Y - 1,
-                size: F,
-                startIndex: B + 1
-              }), D++, V += Y + 1;
+                endIndex: F + 1 + K - 1,
+                size: H,
+                startIndex: F + 1
+              }), U++, z += K + 1;
             }
-            const J = Gt(f.sizeTree);
-            return V !== I && J.shift(), J.reduce(
-              (B, { k: Y, v: it }) => {
-                let dt = B.ranges;
-                return B.prevSize !== 0 && (dt = [
-                  ...B.ranges,
+            const q = Wt(v.sizeTree);
+            return z !== g && q.shift(), q.reduce(
+              (F, { k: K, v: tt }) => {
+                let ut = F.ranges;
+                return F.prevSize !== 0 && (ut = [
+                  ...F.ranges,
                   {
-                    endIndex: Y + I - 1,
-                    size: B.prevSize,
-                    startIndex: B.prevIndex
+                    endIndex: K + g - 1,
+                    size: F.prevSize,
+                    startIndex: F.prevIndex
                   }
                 ]), {
-                  prevIndex: Y + I,
-                  prevSize: it,
-                  ranges: dt
+                  prevIndex: K + g,
+                  prevSize: tt,
+                  ranges: ut
                 };
               },
               {
-                prevIndex: I,
+                prevIndex: g,
                 prevSize: 0,
                 ranges: k
               }
             ).ranges;
           }
-          return Gt(f.sizeTree).reduce(
-            (L, { k: V, v: D }) => ({
-              prevIndex: V + I,
-              prevSize: D,
-              ranges: [...L.ranges, { endIndex: V + I - 1, size: L.prevSize, startIndex: L.prevIndex }]
+          return Wt(v.sizeTree).reduce(
+            (L, { k: z, v: U }) => ({
+              prevIndex: z + g,
+              prevSize: U,
+              ranges: [...L.ranges, { endIndex: z + g - 1, size: L.prevSize, startIndex: L.prevIndex }]
             }),
             {
               prevIndex: 0,
-              prevSize: F,
+              prevSize: H,
               ranges: []
             }
           ).ranges;
@@ -890,77 +890,77 @@ const Oo = {
       ),
       n
     );
-    const R = ht(
-      x(
+    const R = gt(
+      T(
         i,
-        _(v, h),
-        E(([I, { offsetTree: f }, b]) => {
-          const k = -I;
-          return ie(k, f, b);
+        _(y, p),
+        B(([g, { offsetTree: v }, x]) => {
+          const k = -g;
+          return re(k, v, x);
         })
       )
     );
     return O(
-      x(
+      T(
         i,
-        _(v, h),
-        E(([I, f, b]) => {
-          if (f.groupIndices.length > 0) {
-            if (j(f.sizeTree))
-              return f;
-            let F = Kt();
-            const L = st(m);
-            let V = 0, D = 0, J = 0;
-            for (; V < -I; ) {
-              J = L[D];
-              const B = L[D + 1] - J - 1;
-              D++, V += B + 1;
+        _(y, p),
+        B(([g, v, x]) => {
+          if (v.groupIndices.length > 0) {
+            if (Y(v.sizeTree))
+              return v;
+            let H = Ut();
+            const L = lt(f);
+            let z = 0, U = 0, q = 0;
+            for (; z < -g; ) {
+              q = L[U];
+              const F = L[U + 1] - q - 1;
+              U++, z += F + 1;
             }
-            if (F = Gt(f.sizeTree).reduce((B, { k: Y, v: it }) => pt(B, Math.max(0, Y + I), it), F), V !== -I) {
-              const B = re(f.sizeTree, J);
-              F = pt(F, 0, B);
-              const Y = Ct(f.sizeTree, -I + 1)[1];
-              F = pt(F, 1, Y);
+            if (H = Wt(v.sizeTree).reduce((F, { k: K, v: tt }) => ht(F, Math.max(0, K + g), tt), H), z !== -g) {
+              const F = ne(v.sizeTree, q);
+              H = ht(H, 0, F);
+              const K = yt(v.sizeTree, -g + 1)[1];
+              H = ht(H, 1, K);
             }
             return {
-              ...f,
-              sizeTree: F,
-              ...Pe(f.offsetTree, 0, F, b)
+              ...v,
+              sizeTree: H,
+              ...Pe(v.offsetTree, 0, H, x)
             };
           } else {
-            const F = Gt(f.sizeTree).reduce((L, { k: V, v: D }) => pt(L, Math.max(0, V + I), D), Kt());
+            const H = Wt(v.sizeTree).reduce((L, { k: z, v: U }) => ht(L, Math.max(0, z + g), U), Ut());
             return {
-              ...f,
-              sizeTree: F,
-              ...Pe(f.offsetTree, 0, F, b)
+              ...v,
+              sizeTree: H,
+              ...Pe(v.offsetTree, 0, H, x)
             };
           }
         })
       ),
-      v
+      y
     ), {
-      beforeUnshiftWith: T,
+      beforeUnshiftWith: S,
       // input
-      data: g,
-      defaultItemSize: p,
+      data: h,
+      defaultItemSize: m,
       firstItemIndex: l,
-      fixedItemSize: a,
-      gap: h,
+      fixedItemSize: u,
+      gap: p,
       groupIndices: c,
-      itemSize: S,
-      listRefresh: u,
+      itemSize: I,
+      listRefresh: a,
       shiftWith: i,
       shiftWithOffset: R,
       sizeRanges: n,
       // output
-      sizes: v,
+      sizes: y,
       statefulTotalCount: r,
       totalCount: o,
       trackItemSizes: d,
       unshiftWith: s
     };
   },
-  X(Vt, Ne),
+  Q(Vt, Ne),
   { singleton: !0 }
 );
 function Lo(t) {
@@ -972,54 +972,54 @@ function Lo(t) {
     }
   );
 }
-const Nn = U(
+const Nn = $(
   ([{ groupIndices: t, sizes: e, totalCount: n }, { headerHeight: o, scrollTop: r }]) => {
-    const s = $(), i = $(), l = ht(x(s, E(Lo)));
+    const s = D(), i = D(), l = gt(T(s, B(Lo)));
     return O(
-      x(
+      T(
         l,
-        E((c) => c.totalCount)
+        B((c) => c.totalCount)
       ),
       n
     ), O(
-      x(
+      T(
         l,
-        E((c) => c.groupIndices)
+        B((c) => c.groupIndices)
       ),
       t
     ), O(
-      x(
-        rt(r, e, o),
-        P(([c, a]) => Re(a)),
-        E(([c, a, p]) => Ct(a.groupOffsetTree, Math.max(c - p, 0), "v")[0]),
-        Z(),
-        E((c) => [c])
+      T(
+        st(r, e, o),
+        A(([c, u]) => ye(u)),
+        B(([c, u, m]) => yt(u.groupOffsetTree, Math.max(c - m, 0), "v")[0]),
+        J(),
+        B((c) => [c])
       ),
       i
     ), { groupCounts: s, topItemsIndexes: i };
   },
-  X(Et, at)
-), Pt = U(
+  Q(Bt, dt)
+), Pt = $(
   ([{ log: t }]) => {
-    const e = C(!1), n = ht(
-      x(
+    const e = C(!1), n = gt(
+      T(
         e,
-        P((o) => o),
-        Z()
+        A((o) => o),
+        J()
       )
     );
-    return K(e, (o) => {
-      o && st(t)("props updated", {}, mt.DEBUG);
+    return j(e, (o) => {
+      o && lt(t)("props updated", {}, pt.DEBUG);
     }), { didMount: n, propsReady: e };
   },
-  X(Vt),
+  Q(Vt),
   { singleton: !0 }
 ), zo = typeof document < "u" && "scrollBehavior" in document.documentElement.style;
 function Dn(t) {
   const e = typeof t == "number" ? { index: t } : t;
   return e.align || (e.align = "start"), (!e.behavior || !zo) && (e.behavior = "auto"), e.offset || (e.offset = 0), e;
 }
-const ce = U(
+const ie = $(
   ([
     { gap: t, listRefresh: e, sizes: n, totalCount: o },
     {
@@ -1028,58 +1028,58 @@ const ce = U(
       footerHeight: i,
       headerHeight: l,
       scrollingInProgress: c,
-      scrollTo: a,
-      smoothScrollTargetReached: p,
-      viewportHeight: S
+      scrollTo: u,
+      smoothScrollTargetReached: m,
+      viewportHeight: I
     },
-    { log: g }
+    { log: h }
   ]) => {
-    const h = $(), w = $(), v = C(0);
-    let m = null, d = null, u = null;
-    function T() {
-      m && (m(), m = null), u && (u(), u = null), d && (clearTimeout(d), d = null), G(c, !1);
+    const p = D(), w = D(), y = C(0);
+    let f = null, d = null, a = null;
+    function S() {
+      f && (f(), f = null), a && (a(), a = null), d && (clearTimeout(d), d = null), G(c, !1);
     }
     return O(
-      x(
-        h,
-        _(n, S, o, v, l, i, g),
+      T(
+        p,
+        _(n, I, o, y, l, i, h),
         _(t, s, r),
-        E(
+        B(
           ([
-            [R, I, f, b, k, F, L, V],
-            D,
-            J,
-            nt
+            [R, g, v, x, k, H, L, z],
+            U,
+            q,
+            ct
           ]) => {
-            const B = Dn(R), { align: Y, behavior: it, offset: dt } = B, St = b - 1, ft = _n(B, I, St);
-            let ut = ie(ft, I.offsetTree, D) + F;
-            Y === "end" ? (ut += J + Ct(I.sizeTree, ft)[1] - f + nt, ft === St && (ut += L)) : Y === "center" ? ut += (J + Ct(I.sizeTree, ft)[1] - f + nt) / 2 : ut -= k, dt && (ut += dt);
-            const At = (xt) => {
-              T(), xt ? (V("retrying to scroll to", { location: R }, mt.DEBUG), G(h, R)) : (G(w, !0), V("list did not change, scroll successful", {}, mt.DEBUG));
+            const F = Dn(R), { align: K, behavior: tt, offset: ut } = F, It = x - 1, ft = _n(F, g, It);
+            let mt = re(ft, g.offsetTree, U) + H;
+            K === "end" ? (mt += q + yt(g.sizeTree, ft)[1] - v + ct, ft === It && (mt += L)) : K === "center" ? mt += (q + yt(g.sizeTree, ft)[1] - v + ct) / 2 : mt -= k, ut && (mt += ut);
+            const kt = (St) => {
+              S(), St ? (z("retrying to scroll to", { location: R }, pt.DEBUG), G(p, R)) : (G(w, !0), z("list did not change, scroll successful", {}, pt.DEBUG));
             };
-            if (T(), it === "smooth") {
-              let xt = !1;
-              u = K(e, (Xt) => {
-                xt = xt || Xt;
-              }), m = bt(p, () => {
-                At(xt);
+            if (S(), tt === "smooth") {
+              let St = !1;
+              a = j(e, (Zt) => {
+                St = St || Zt;
+              }), f = vt(m, () => {
+                kt(St);
               });
             } else
-              m = bt(x(e, Vo(150)), At);
+              f = vt(T(e, Vo(150)), kt);
             return d = setTimeout(() => {
-              T();
-            }, 1200), G(c, !0), V("scrolling from index to", { behavior: it, index: ft, top: ut }, mt.DEBUG), { behavior: it, top: ut };
+              S();
+            }, 1200), G(c, !0), z("scrolling from index to", { behavior: tt, index: ft, top: mt }, pt.DEBUG), { behavior: tt, top: mt };
           }
         )
       ),
-      a
+      u
     ), {
       scrollTargetReached: w,
-      scrollToIndex: h,
-      topListHeight: v
+      scrollToIndex: p,
+      topListHeight: y
     };
   },
-  X(Et, at, Vt),
+  Q(Bt, dt, Vt),
   { singleton: !0 }
 );
 function Vo(t) {
@@ -1101,54 +1101,54 @@ function Ue(t, e) {
   const n = e - 1;
   return typeof t == "number" ? t : t.index === "LAST" ? n : t.index;
 }
-const ue = U(
+const le = $(
   ([{ defaultItemSize: t, listRefresh: e, sizes: n }, { scrollTop: o }, { scrollTargetReached: r, scrollToIndex: s }, { didMount: i }]) => {
-    const l = C(!0), c = C(0), a = C(!0);
+    const l = C(!0), c = C(0), u = C(!0);
     return O(
-      x(
+      T(
         i,
         _(c),
-        P(([p, S]) => !!S),
-        yt(!1)
+        A(([m, I]) => !!I),
+        bt(!1)
       ),
       l
     ), O(
-      x(
+      T(
         i,
         _(c),
-        P(([p, S]) => !!S),
-        yt(!1)
+        A(([m, I]) => !!I),
+        bt(!1)
       ),
-      a
-    ), K(
-      x(
-        rt(e, i),
-        _(l, n, t, a),
-        P(([[, p], S, { sizeTree: g }, h, w]) => p && (!j(g) || Me(h)) && !S && !w),
+      u
+    ), j(
+      T(
+        st(e, i),
+        _(l, n, t, u),
+        A(([[, m], I, { sizeTree: h }, p, w]) => m && (!Y(h) || Me(p)) && !I && !w),
         _(c)
       ),
-      ([, p]) => {
-        bt(r, () => {
-          G(a, !0);
+      ([, m]) => {
+        vt(r, () => {
+          G(u, !0);
         }), $e(4, () => {
-          bt(o, () => {
+          vt(o, () => {
             G(l, !0);
-          }), G(s, p);
+          }), G(s, m);
         });
       }
     ), {
-      initialItemFinalLocationReached: a,
+      initialItemFinalLocationReached: u,
       initialTopMostItemIndex: c,
       scrolledToInitialItem: l
     };
   },
-  X(Et, at, ce, Pt),
+  Q(Bt, dt, ie, Pt),
   { singleton: !0 }
 );
 function $n(t, e) {
   return Math.abs(t - e) < 1.01;
 }
-const le = "up", te = "down", Po = "none", Ao = {
+const se = "up", Jt = "down", Po = "none", Ao = {
   atBottom: !1,
   notAtBottomBecause: "NOT_SHOWING_LAST_ITEM",
   state: {
@@ -1157,184 +1157,184 @@ const le = "up", te = "down", Po = "none", Ao = {
     scrollTop: 0,
     viewportHeight: 0
   }
-}, Mo = 0, ae = U(([{ footerHeight: t, headerHeight: e, scrollBy: n, scrollContainerState: o, scrollTop: r, viewportHeight: s }]) => {
-  const i = C(!1), l = C(!0), c = $(), a = $(), p = C(4), S = C(Mo), g = ct(
-    x(
-      dn(x(A(r), jt(1), yt(!0)), x(A(r), jt(1), yt(!1), an(100))),
-      Z()
+}, Mo = 0, ce = $(([{ footerHeight: t, headerHeight: e, scrollBy: n, scrollContainerState: o, scrollTop: r, viewportHeight: s }]) => {
+  const i = C(!1), l = C(!0), c = D(), u = D(), m = C(4), I = C(Mo), h = at(
+    T(
+      dn(T(P(r), Kt(1), bt(!0)), T(P(r), Kt(1), bt(!1), an(100))),
+      J()
     ),
     !1
-  ), h = ct(
-    x(dn(x(n, yt(!0)), x(n, yt(!1), an(200))), Z()),
+  ), p = at(
+    T(dn(T(n, bt(!0)), T(n, bt(!1), an(200))), J()),
     !1
   );
   O(
-    x(
-      rt(A(r), A(S)),
-      E(([u, T]) => u <= T),
-      Z()
+    T(
+      st(P(r), P(I)),
+      B(([a, S]) => a <= S),
+      J()
     ),
     l
-  ), O(x(l, Lt(50)), a);
-  const w = ht(
-    x(
-      rt(o, A(s), A(e), A(t), A(p)),
-      Rt((u, [{ scrollHeight: T, scrollTop: R }, I, f, b, k]) => {
-        const F = R + I - T > -k, L = {
-          scrollHeight: T,
+  ), O(T(l, Lt(50)), u);
+  const w = gt(
+    T(
+      st(o, P(s), P(e), P(t), P(m)),
+      Ht((a, [{ scrollHeight: S, scrollTop: R }, g, v, x, k]) => {
+        const H = R + g - S > -k, L = {
+          scrollHeight: S,
           scrollTop: R,
-          viewportHeight: I
+          viewportHeight: g
         };
-        if (F) {
-          let D, J;
-          return R > u.state.scrollTop ? (D = "SCROLLED_DOWN", J = u.state.scrollTop - R) : (D = "SIZE_DECREASED", J = u.state.scrollTop - R || u.scrollTopDelta), {
+        if (H) {
+          let U, q;
+          return R > a.state.scrollTop ? (U = "SCROLLED_DOWN", q = a.state.scrollTop - R) : (U = "SIZE_DECREASED", q = a.state.scrollTop - R || a.scrollTopDelta), {
             atBottom: !0,
-            atBottomBecause: D,
-            scrollTopDelta: J,
+            atBottomBecause: U,
+            scrollTopDelta: q,
             state: L
           };
         }
-        let V;
-        return L.scrollHeight > u.state.scrollHeight ? V = "SIZE_INCREASED" : I < u.state.viewportHeight ? V = "VIEWPORT_HEIGHT_DECREASING" : R < u.state.scrollTop ? V = "SCROLLING_UPWARDS" : V = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM", {
+        let z;
+        return L.scrollHeight > a.state.scrollHeight ? z = "SIZE_INCREASED" : g < a.state.viewportHeight ? z = "VIEWPORT_HEIGHT_DECREASING" : R < a.state.scrollTop ? z = "SCROLLING_UPWARDS" : z = "NOT_FULLY_SCROLLED_TO_LAST_ITEM_BOTTOM", {
           atBottom: !1,
-          notAtBottomBecause: V,
+          notAtBottomBecause: z,
           state: L
         };
       }, Ao),
-      Z((u, T) => u && u.atBottom === T.atBottom)
+      J((a, S) => a && a.atBottom === S.atBottom)
     )
-  ), v = ct(
-    x(
+  ), y = at(
+    T(
       o,
-      Rt(
-        (u, { scrollHeight: T, scrollTop: R, viewportHeight: I }) => {
-          if ($n(u.scrollHeight, T))
+      Ht(
+        (a, { scrollHeight: S, scrollTop: R, viewportHeight: g }) => {
+          if ($n(a.scrollHeight, S))
             return {
               changed: !1,
               jump: 0,
-              scrollHeight: T,
+              scrollHeight: S,
               scrollTop: R
             };
           {
-            const f = T - (R + I) < 1;
-            return u.scrollTop !== R && f ? {
+            const v = S - (R + g) < 1;
+            return a.scrollTop !== R && v ? {
               changed: !0,
-              jump: u.scrollTop - R,
-              scrollHeight: T,
+              jump: a.scrollTop - R,
+              scrollHeight: S,
               scrollTop: R
             } : {
               changed: !0,
               jump: 0,
-              scrollHeight: T,
+              scrollHeight: S,
               scrollTop: R
             };
           }
         },
         { changed: !1, jump: 0, scrollHeight: 0, scrollTop: 0 }
       ),
-      P((u) => u.changed),
-      E((u) => u.jump)
+      A((a) => a.changed),
+      B((a) => a.jump)
     ),
     0
   );
   O(
-    x(
+    T(
       w,
-      E((u) => u.atBottom)
+      B((a) => a.atBottom)
     ),
     i
-  ), O(x(i, Lt(50)), c);
-  const m = C(te);
+  ), O(T(i, Lt(50)), c);
+  const f = C(Jt);
   O(
-    x(
+    T(
       o,
-      E(({ scrollTop: u }) => u),
-      Z(),
-      Rt(
-        (u, T) => st(h) ? { direction: u.direction, prevScrollTop: T } : { direction: T < u.prevScrollTop ? le : te, prevScrollTop: T },
-        { direction: te, prevScrollTop: 0 }
+      B(({ scrollTop: a }) => a),
+      J(),
+      Ht(
+        (a, S) => lt(p) ? { direction: a.direction, prevScrollTop: S } : { direction: S < a.prevScrollTop ? se : Jt, prevScrollTop: S },
+        { direction: Jt, prevScrollTop: 0 }
       ),
-      E((u) => u.direction)
+      B((a) => a.direction)
     ),
-    m
-  ), O(x(o, Lt(50), yt(Po)), m);
+    f
+  ), O(T(o, Lt(50), bt(Po)), f);
   const d = C(0);
   return O(
-    x(
-      g,
-      P((u) => !u),
-      yt(0)
+    T(
+      h,
+      A((a) => !a),
+      bt(0)
     ),
     d
   ), O(
-    x(
+    T(
       r,
       Lt(100),
-      _(g),
-      P(([u, T]) => !!T),
-      Rt(([u, T], [R]) => [T, R], [0, 0]),
-      E(([u, T]) => T - u)
+      _(h),
+      A(([a, S]) => !!S),
+      Ht(([a, S], [R]) => [S, R], [0, 0]),
+      B(([a, S]) => S - a)
     ),
     d
   ), {
     atBottomState: w,
     atBottomStateChange: c,
-    atBottomThreshold: p,
-    atTopStateChange: a,
-    atTopThreshold: S,
+    atBottomThreshold: m,
+    atTopStateChange: u,
+    atTopThreshold: I,
     isAtBottom: i,
     isAtTop: l,
-    isScrolling: g,
-    lastJumpDueToItemResize: v,
-    scrollDirection: m,
+    isScrolling: h,
+    lastJumpDueToItemResize: y,
+    scrollDirection: f,
     scrollVelocity: d
   };
-}, X(at)), xe = "top", Te = "bottom", hn = "none";
+}, Q(dt)), Se = "top", xe = "bottom", hn = "none";
 function gn(t, e, n) {
-  return typeof t == "number" ? n === le && e === xe || n === te && e === Te ? t : 0 : n === le ? e === xe ? t.main : t.reverse : e === Te ? t.main : t.reverse;
+  return typeof t == "number" ? n === se && e === Se || n === Jt && e === xe ? t : 0 : n === se ? e === Se ? t.main : t.reverse : e === xe ? t.main : t.reverse;
 }
 function In(t, e) {
   var n;
   return typeof t == "number" ? t : (n = t[e]) != null ? n : 0;
 }
-const Ke = U(
+const Ke = $(
   ([{ deviation: t, fixedHeaderHeight: e, headerHeight: n, scrollTop: o, viewportHeight: r }]) => {
-    const s = $(), i = C(0), l = C(0), c = C(0), a = ct(
-      x(
-        rt(
-          A(o),
-          A(r),
-          A(n),
-          A(s, se),
-          A(c),
-          A(i),
-          A(e),
-          A(t),
-          A(l)
+    const s = D(), i = C(0), l = C(0), c = C(0), u = at(
+      T(
+        st(
+          P(o),
+          P(r),
+          P(n),
+          P(s, oe),
+          P(c),
+          P(i),
+          P(e),
+          P(t),
+          P(l)
         ),
-        E(
+        B(
           ([
-            p,
-            S,
-            g,
-            [h, w],
-            v,
             m,
+            I,
+            h,
+            [p, w],
+            y,
+            f,
             d,
-            u,
-            T
+            a,
+            S
           ]) => {
-            const R = p - u, I = m + d, f = Math.max(g - R, 0);
-            let b = hn;
-            const k = In(T, xe), F = In(T, Te);
-            return h -= u, h += g + d, w += g + d, w -= u, h > p + I - k && (b = le), w < p - f + S + F && (b = te), b !== hn ? [
-              Math.max(R - g - gn(v, xe, b) - k, 0),
-              R - f - d + S + gn(v, Te, b) + F
+            const R = m - a, g = f + d, v = Math.max(h - R, 0);
+            let x = hn;
+            const k = In(S, Se), H = In(S, xe);
+            return p -= a, p += h + d, w += h + d, w -= a, p > m + g - k && (x = se), w < m - v + I + H && (x = Jt), x !== hn ? [
+              Math.max(R - h - gn(y, Se, x) - k, 0),
+              R - v - d + I + gn(y, xe, x) + H
             ] : null;
           }
         ),
-        P((p) => p != null),
-        Z(se)
+        A((m) => m != null),
+        J(oe)
       ),
       [0, 0]
     );
@@ -1345,17 +1345,17 @@ const Ke = U(
       overscan: c,
       topListHeight: i,
       // output
-      visibleRange: a
+      visibleRange: u
     };
   },
-  X(at),
+  Q(dt),
   { singleton: !0 }
 );
 function Wo(t, e, n) {
-  if (Re(e)) {
+  if (ye(e)) {
     const o = Gn(t, e);
     return [
-      { index: Ct(e.groupOffsetTree, o)[0], offset: 0, size: 0 },
+      { index: yt(e.groupOffsetTree, o)[0], offset: 0, size: 0 },
       { data: n == null ? void 0 : n[0], index: o, offset: 0, size: 0 }
     ];
   }
@@ -1372,370 +1372,371 @@ const Be = {
   topListHeight: 0,
   totalCount: 0
 };
-function Ie(t, e, n, o, r, s) {
+function ge(t, e, n, o, r, s) {
   const { lastIndex: i, lastOffset: l, lastSize: c } = r;
-  let a = 0, p = 0;
+  let u = 0, m = 0;
   if (t.length > 0) {
-    a = t[0].offset;
-    const v = t[t.length - 1];
-    p = v.offset + v.size;
+    u = t[0].offset;
+    const y = t[t.length - 1];
+    m = y.offset + y.size;
   }
-  const S = n - i, g = l + S * c + (S - 1) * o, h = a, w = g - p;
+  const I = n - i, h = l + I * c + (I - 1) * o, p = u, w = h - m;
   return {
-    bottom: p,
+    bottom: m,
     firstItemIndex: s,
     items: Sn(t, r, s),
     offsetBottom: w,
-    offsetTop: a,
-    top: h,
+    offsetTop: u,
+    top: p,
     topItems: Sn(e, r, s),
-    topListHeight: e.reduce((v, m) => m.size + v, 0),
+    topListHeight: e.reduce((y, f) => f.size + y, 0),
     totalCount: n
   };
 }
 function Un(t, e, n, o, r, s) {
   let i = 0;
   if (n.groupIndices.length > 0)
-    for (const p of n.groupIndices) {
-      if (p - i >= t)
+    for (const m of n.groupIndices) {
+      if (m - i >= t)
         break;
       i++;
     }
-  const l = t + i, c = Ue(e, l), a = Array.from({ length: l }).map((p, S) => ({
-    data: s[S + c],
-    index: S + c,
+  const l = t + i, c = Ue(e, l), u = Array.from({ length: l }).map((m, I) => ({
+    data: s[I + c],
+    index: I + c,
     offset: 0,
     size: 0
   }));
-  return Ie(a, [], l, r, n, o);
+  return ge(u, [], l, r, n, o);
 }
 function Sn(t, e, n) {
   if (t.length === 0)
     return [];
-  if (!Re(e))
-    return t.map((a) => ({ ...a, index: a.index + n, originalIndex: a.index }));
-  const o = t[0].index, r = t[t.length - 1].index, s = [], i = ye(e.groupOffsetTree, o, r);
+  if (!ye(e))
+    return t.map((u) => ({ ...u, index: u.index + n, originalIndex: u.index }));
+  const o = t[0].index, r = t[t.length - 1].index, s = [], i = ve(e.groupOffsetTree, o, r);
   let l, c = 0;
-  for (const a of t) {
-    (!l || l.end < a.index) && (l = i.shift(), c = e.groupIndices.indexOf(l.start));
-    let p;
-    a.index === l.start ? p = {
+  for (const u of t) {
+    (!l || l.end < u.index) && (l = i.shift(), c = e.groupIndices.indexOf(l.start));
+    let m;
+    u.index === l.start ? m = {
       index: c,
       type: "group"
-    } : p = {
+    } : m = {
       groupIndex: c,
-      index: a.index - (c + 1) + n
+      index: u.index - (c + 1) + n
     }, s.push({
-      ...p,
-      data: a.data,
-      offset: a.offset,
-      originalIndex: a.index,
-      size: a.size
+      ...m,
+      data: u.data,
+      offset: u.offset,
+      originalIndex: u.index,
+      size: u.size
     });
   }
   return s;
 }
-const Dt = U(
+const Nt = $(
   ([
     { data: t, firstItemIndex: e, gap: n, sizes: o, totalCount: r },
     s,
     { listBoundary: i, topListHeight: l, visibleRange: c },
-    { initialTopMostItemIndex: a, scrolledToInitialItem: p },
-    { topListHeight: S },
-    g,
-    { didMount: h },
+    { initialTopMostItemIndex: u, scrolledToInitialItem: m },
+    { topListHeight: I },
+    h,
+    { didMount: p },
     { recalcInProgress: w }
   ]) => {
-    const v = C([]), m = C(0), d = $();
-    O(s.topItemsIndexes, v);
-    const u = ct(
-      x(
-        rt(
-          h,
-          w,
-          A(c, se),
-          A(r),
-          A(o),
-          A(a),
+    const y = C([]), f = C(0), d = D(), a = D();
+    O(s.topItemsIndexes, y);
+    const S = at(
+      T(
+        st(
           p,
-          A(v),
-          A(e),
-          A(n),
+          w,
+          P(c, oe),
+          P(r),
+          P(o),
+          P(u),
+          m,
+          P(y),
+          P(e),
+          P(n),
           t
         ),
-        P(([f, b, , k, , , , , , , F]) => {
-          const L = F && F.length !== k;
-          return f && !b && !L;
+        A(([x, k, , H, , , , , , , L]) => {
+          const z = L && L.length !== H;
+          return x && !k && !z;
         }),
-        E(
+        B(
           ([
             ,
             ,
-            [f, b],
-            k,
-            F,
+            [x, k],
+            H,
             L,
-            V,
-            D,
-            J,
-            nt,
-            B
+            z,
+            U,
+            q,
+            ct,
+            F,
+            K
           ]) => {
-            const Y = F, { offsetTree: it, sizeTree: dt } = Y, St = st(m);
-            if (k === 0)
-              return { ...Be, totalCount: k };
-            if (f === 0 && b === 0)
-              return St === 0 ? { ...Be, totalCount: k } : Un(St, L, F, J, nt, B || []);
-            if (j(dt))
-              return St > 0 ? null : Ie(
-                Wo(Ue(L, k), Y, B),
+            const tt = L, { offsetTree: ut, sizeTree: It } = tt, ft = lt(f);
+            if (H === 0)
+              return { ...Be, totalCount: H };
+            if (x === 0 && k === 0)
+              return ft === 0 ? { ...Be, totalCount: H } : Un(ft, z, L, ct, F, K || []);
+            if (Y(It))
+              return ft > 0 ? null : ge(
+                Wo(Ue(z, H), tt, K),
                 [],
-                k,
-                nt,
-                Y,
-                J
+                H,
+                F,
+                tt,
+                ct
               );
-            const ft = [];
-            if (D.length > 0) {
-              const Mt = D[0], vt = D[D.length - 1];
-              let Bt = 0;
-              for (const y of ye(dt, Mt, vt)) {
-                const N = y.value, Q = Math.max(y.start, Mt), lt = Math.min(y.end, vt);
-                for (let tt = Q; tt <= lt; tt++)
-                  ft.push({ data: B == null ? void 0 : B[tt], index: tt, offset: Bt, size: N }), Bt += N;
+            const mt = [];
+            if (q.length > 0) {
+              const At = q[0], b = q[q.length - 1];
+              let N = 0;
+              for (const Z of ve(It, At, b)) {
+                const nt = Z.value, ot = Math.max(Z.start, At), xt = Math.min(Z.end, b);
+                for (let it = ot; it <= xt; it++)
+                  mt.push({ data: K == null ? void 0 : K[it], index: it, offset: N, size: nt }), N += nt;
               }
             }
-            if (!V)
-              return Ie([], ft, k, nt, Y, J);
-            const ut = D.length > 0 ? D[D.length - 1] + 1 : 0, At = Ho(it, f, b, ut);
-            if (At.length === 0)
+            if (!U)
+              return ge([], mt, H, F, tt, ct);
+            const kt = q.length > 0 ? q[q.length - 1] + 1 : 0, St = Ho(ut, x, k, kt);
+            if (St.length === 0)
               return null;
-            const xt = k - 1, Xt = ve([], (Mt) => {
-              for (const vt of At) {
-                const Bt = vt.value;
-                let y = Bt.offset, N = vt.start;
-                const Q = Bt.size;
-                if (Bt.offset < f) {
-                  N += Math.floor((f - Bt.offset + nt) / (Q + nt));
-                  const tt = N - vt.start;
-                  y += tt * Q + tt * nt;
+            const Zt = H - 1, be = we([], (At) => {
+              for (const b of St) {
+                const N = b.value;
+                let Z = N.offset, nt = b.start;
+                const ot = N.size;
+                if (N.offset < x) {
+                  nt += Math.floor((x - N.offset + F) / (ot + F));
+                  const it = nt - b.start;
+                  Z += it * ot + it * F;
                 }
-                N < ut && (y += (ut - N) * Q, N = ut);
-                const lt = Math.min(vt.end, xt);
-                for (let tt = N; tt <= lt && !(y >= b); tt++)
-                  Mt.push({ data: B == null ? void 0 : B[tt], index: tt, offset: y, size: Q }), y += Q + nt;
+                nt < kt && (Z += (kt - nt) * ot, nt = kt);
+                const xt = Math.min(b.end, Zt);
+                for (let it = nt; it <= xt && !(Z >= k); it++)
+                  At.push({ data: K == null ? void 0 : K[it], index: it, offset: Z, size: ot }), Z += ot + F;
               }
             });
-            return Ie(Xt, ft, k, nt, Y, J);
+            let ue = ge(be, mt, H, F, tt, ct);
+            return G(a, !0), ue;
           }
         ),
         //@ts-expect-error filter needs to be fixed
-        P((f) => f !== null),
-        Z()
+        A((x) => x !== null),
+        J()
       ),
       Be
     );
     O(
-      x(
+      T(
         t,
-        P(Me),
-        E((f) => f == null ? void 0 : f.length)
+        A(Me),
+        B((x) => x == null ? void 0 : x.length)
       ),
       r
     ), O(
-      x(
-        u,
-        E((f) => f.topListHeight)
+      T(
+        S,
+        B((x) => x.topListHeight)
       ),
-      S
-    ), O(S, l), O(
-      x(
-        u,
-        E((f) => [f.top, f.bottom])
+      I
+    ), O(I, l), O(
+      T(
+        S,
+        B((x) => [x.top, x.bottom])
       ),
       i
     ), O(
-      x(
-        u,
-        E((f) => f.items)
+      T(
+        S,
+        B((x) => x.items)
       ),
       d
     );
-    const T = ht(
-      x(
-        u,
-        P(({ items: f }) => f.length > 0),
+    const R = gt(
+      T(
+        S,
+        A(({ items: x }) => x.length > 0),
         _(r, t),
-        P(([{ items: f }, b]) => f[f.length - 1].originalIndex === b - 1),
-        E(([, f, b]) => [f - 1, b]),
-        Z(se),
-        E(([f]) => f)
+        A(([{ items: x }, k]) => x[x.length - 1].originalIndex === k - 1),
+        B(([, x, k]) => [x - 1, k]),
+        J(oe),
+        B(([x]) => x)
       )
-    ), R = ht(
-      x(
-        u,
+    ), g = gt(
+      T(
+        S,
         Lt(200),
-        P(({ items: f, topItems: b }) => f.length > 0 && f[0].originalIndex === b.length),
-        E(({ items: f }) => f[0].index),
-        Z()
+        A(({ items: x, topItems: k }) => x.length > 0 && x[0].originalIndex === k.length),
+        B(({ items: x }) => x[0].index),
+        J()
       )
-    ), I = ht(
-      x(
-        u,
-        P(({ items: f }) => f.length > 0),
-        E(({ items: f }) => {
-          let b = 0, k = f.length - 1;
-          for (; f[b].type === "group" && b < k; )
-            b++;
-          for (; f[k].type === "group" && k > b; )
-            k--;
+    ), v = gt(
+      T(
+        S,
+        A(({ items: x }) => x.length > 0),
+        B(({ items: x }) => {
+          let k = 0, H = x.length - 1;
+          for (; x[k].type === "group" && k < H; )
+            k++;
+          for (; x[H].type === "group" && H > k; )
+            H--;
           return {
-            endIndex: f[k].index,
-            startIndex: f[b].index
+            endIndex: x[H].index,
+            startIndex: x[k].index
           };
         }),
-        Z(Mn)
+        J(Mn)
       )
     );
-    return { endReached: T, initialItemCount: m, itemsRendered: d, listState: u, rangeChanged: I, startReached: R, topItemsIndexes: v, ...g };
+    return { endReached: R, initialItemCount: f, itemsRendered: d, listState: S, rangeChanged: v, startReached: g, topItemsIndexes: y, didCalcList: a, ...h };
   },
-  X(
-    Et,
+  Q(
+    Bt,
     Nn,
     Ke,
-    ue,
+    le,
+    ie,
     ce,
-    ae,
     Pt,
     Ne
   ),
   { singleton: !0 }
-), Kn = U(
+), Kn = $(
   ([{ fixedFooterHeight: t, fixedHeaderHeight: e, footerHeight: n, headerHeight: o }, { listState: r }]) => {
-    const s = $(), i = ct(
-      x(
-        rt(n, t, o, e, r),
-        E(([l, c, a, p, S]) => l + c + a + p + S.offsetBottom + S.bottom)
+    const s = D(), i = at(
+      T(
+        st(n, t, o, e, r),
+        B(([l, c, u, m, I]) => l + c + u + m + I.offsetBottom + I.bottom)
       ),
       0
     );
-    return O(A(i), s), { totalListHeight: i, totalListHeightChanged: s };
+    return O(P(i), s), { totalListHeight: i, totalListHeightChanged: s };
   },
-  X(at, Dt),
+  Q(dt, Nt),
   { singleton: !0 }
-), Go = U(
+), Go = $(
   ([{ viewportHeight: t }, { totalListHeight: e }]) => {
-    const n = C(!1), o = ct(
-      x(
-        rt(n, t, e),
-        P(([r]) => r),
-        E(([, r, s]) => Math.max(0, r - s)),
+    const n = C(!1), o = at(
+      T(
+        st(n, t, e),
+        A(([r]) => r),
+        B(([, r, s]) => Math.max(0, r - s)),
         Lt(0),
-        Z()
+        J()
       ),
       0
     );
     return { alignToBottom: n, paddingTopAddition: o };
   },
-  X(at, Kn),
+  Q(dt, Kn),
   { singleton: !0 }
 );
 function xn(t) {
   return t ? t === "smooth" ? "smooth" : "auto" : !1;
 }
-const _o = (t, e) => typeof t == "function" ? xn(t(e)) : e && xn(t), No = U(
+const _o = (t, e) => typeof t == "function" ? xn(t(e)) : e && xn(t), No = $(
   ([
     { listRefresh: t, totalCount: e, fixedItemSize: n },
     { atBottomState: o, isAtBottom: r },
     { scrollToIndex: s },
     { scrolledToInitialItem: i },
     { didMount: l, propsReady: c },
-    { log: a },
-    { scrollingInProgress: p }
+    { log: u },
+    { scrollingInProgress: m }
   ]) => {
-    const S = C(!1), g = $();
-    let h = null;
-    function w(m) {
+    const I = C(!1), h = D();
+    let p = null;
+    function w(f) {
       G(s, {
         align: "end",
-        behavior: m,
+        behavior: f,
         index: "LAST"
       });
     }
-    K(
-      x(
-        rt(x(A(e), jt(1)), l),
-        _(A(S), r, i, p),
-        E(([[m, d], u, T, R, I]) => {
-          let f = d && R, b = "auto";
-          return f && (b = _o(u, T || I), f = f && !!b), { followOutputBehavior: b, shouldFollow: f, totalCount: m };
+    j(
+      T(
+        st(T(P(e), Kt(1)), l),
+        _(P(I), r, i, m),
+        B(([[f, d], a, S, R, g]) => {
+          let v = d && R, x = "auto";
+          return v && (x = _o(a, S || g), v = v && !!x), { followOutputBehavior: x, shouldFollow: v, totalCount: f };
         }),
-        P(({ shouldFollow: m }) => m)
+        A(({ shouldFollow: f }) => f)
       ),
-      ({ followOutputBehavior: m, totalCount: d }) => {
-        h && (h(), h = null), st(n) ? requestAnimationFrame(() => {
-          st(a)("following output to ", { totalCount: d }, mt.DEBUG), w(m);
-        }) : h = bt(t, () => {
-          st(a)("following output to ", { totalCount: d }, mt.DEBUG), w(m), h = null;
+      ({ followOutputBehavior: f, totalCount: d }) => {
+        p && (p(), p = null), lt(n) ? requestAnimationFrame(() => {
+          lt(u)("following output to ", { totalCount: d }, pt.DEBUG), w(f);
+        }) : p = vt(t, () => {
+          lt(u)("following output to ", { totalCount: d }, pt.DEBUG), w(f), p = null;
         });
       }
     );
-    function v(m) {
-      const d = bt(o, (u) => {
-        m && !u.atBottom && u.notAtBottomBecause === "SIZE_INCREASED" && !h && (st(a)("scrolling to bottom due to increased size", {}, mt.DEBUG), w("auto"));
+    function y(f) {
+      const d = vt(o, (a) => {
+        f && !a.atBottom && a.notAtBottomBecause === "SIZE_INCREASED" && !p && (lt(u)("scrolling to bottom due to increased size", {}, pt.DEBUG), w("auto"));
       });
       setTimeout(d, 100);
     }
-    return K(
-      x(
-        rt(A(S), e, c),
-        P(([m, , d]) => m && d),
-        Rt(
-          ({ value: m }, [, d]) => ({ refreshed: m === d, value: d }),
+    return j(
+      T(
+        st(P(I), e, c),
+        A(([f, , d]) => f && d),
+        Ht(
+          ({ value: f }, [, d]) => ({ refreshed: f === d, value: d }),
           { refreshed: !1, value: 0 }
         ),
-        P(({ refreshed: m }) => m),
-        _(S, e)
+        A(({ refreshed: f }) => f),
+        _(I, e)
       ),
-      ([, m]) => {
-        st(i) && v(m !== !1);
+      ([, f]) => {
+        lt(i) && y(f !== !1);
       }
-    ), K(g, () => {
-      v(st(S) !== !1);
-    }), K(rt(A(S), o), ([m, d]) => {
-      m && !d.atBottom && d.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && w("auto");
-    }), { autoscrollToBottom: g, followOutput: S };
+    ), j(h, () => {
+      y(lt(I) !== !1);
+    }), j(st(P(I), o), ([f, d]) => {
+      f && !d.atBottom && d.notAtBottomBecause === "VIEWPORT_HEIGHT_DECREASING" && w("auto");
+    }), { autoscrollToBottom: h, followOutput: I };
   },
-  X(Et, ae, ce, ue, Pt, Vt, at)
-), Do = U(
+  Q(Bt, ce, ie, le, Pt, Vt, dt)
+), Do = $(
   ([{ data: t, firstItemIndex: e, gap: n, sizes: o }, { initialTopMostItemIndex: r }, { initialItemCount: s, listState: i }, { didMount: l }]) => (O(
-    x(
+    T(
       l,
       _(s),
-      P(([, c]) => c !== 0),
+      A(([, c]) => c !== 0),
       _(r, o, e, n, t),
-      E(([[, c], a, p, S, g, h = []]) => Un(c, a, p, S, g, h))
+      B(([[, c], u, m, I, h, p = []]) => Un(c, u, m, I, h, p))
     ),
     i
   ), {}),
-  X(Et, ue, Dt, Pt),
+  Q(Bt, le, Nt, Pt),
   { singleton: !0 }
-), $o = U(
+), $o = $(
   ([{ didMount: t }, { scrollTo: e }, { listState: n }]) => {
     const o = C(0);
-    return K(
-      x(
+    return j(
+      T(
         t,
         _(o),
-        P(([, r]) => r !== 0),
-        E(([, r]) => ({ top: r }))
+        A(([, r]) => r !== 0),
+        B(([, r]) => ({ top: r }))
       ),
       (r) => {
-        bt(
-          x(
+        vt(
+          T(
             n,
-            jt(1),
-            P((s) => s.items.length > 1)
+            Kt(1),
+            A((s) => s.items.length > 1)
           ),
           () => {
             requestAnimationFrame(() => {
@@ -1748,7 +1749,7 @@ const _o = (t, e) => typeof t == "function" ? xn(t(e)) : e && xn(t), No = U(
       initialScrollTop: o
     };
   },
-  X(Pt, at, Dt),
+  Q(Pt, dt, Nt),
   { singleton: !0 }
 ), Uo = ({
   itemBottom: t,
@@ -1756,92 +1757,100 @@ const _o = (t, e) => typeof t == "function" ? xn(t(e)) : e && xn(t), No = U(
   locationParams: { align: n, behavior: o, ...r },
   viewportBottom: s,
   viewportTop: i
-}) => e < i ? { ...r, align: n != null ? n : "start", behavior: o } : t > s ? { ...r, align: n != null ? n : "end", behavior: o } : null, Ko = U(
+}) => e < i ? { ...r, align: n != null ? n : "start", behavior: o } : t > s ? { ...r, align: n != null ? n : "end", behavior: o } : null, Ko = $(
   ([
     { gap: t, sizes: e, totalCount: n },
     { fixedFooterHeight: o, fixedHeaderHeight: r, headerHeight: s, scrollingInProgress: i, scrollTop: l, viewportHeight: c },
-    { scrollToIndex: a }
+    { scrollToIndex: u },
+    { didCalcList: m }
   ]) => {
-    const p = $();
-    return O(
-      x(
-        p,
+    const I = D();
+    let h = null;
+    return j(
+      T(
+        I,
         _(e, c, n, s, r, o, l),
-        _(t),
-        E(([[S, g, h, w, v, m, d, u], T]) => {
-          const { align: R, behavior: I, calculateViewLocation: f = Uo, done: b, ...k } = S, F = _n(S, g, w - 1), L = ie(F, g.offsetTree, T) + v + m, V = L + Ct(g.sizeTree, F)[1], D = u + m, J = u + h - d, nt = f({
-            itemBottom: V,
-            itemTop: L,
-            locationParams: { align: R, behavior: I, ...k },
-            viewportBottom: J,
-            viewportTop: D
+        _(t)
+      ),
+      ([[p, w, y, f, d, a, S, R], g]) => {
+        const { align: v, behavior: x, calculateViewLocation: k = Uo, done: H, targetsNextRefresh: L, ...z } = p, U = _n(p, w, f - 1), q = re(U, w.offsetTree, g) + d + a, ct = q + yt(w.sizeTree, U)[1], F = R + a, K = R + y - S;
+        function tt() {
+          const ut = k({
+            itemBottom: ct,
+            itemTop: q,
+            locationParams: { align: v, behavior: x, ...z },
+            viewportBottom: K,
+            viewportTop: F
           });
-          return nt ? b && bt(
-            x(
+          ut ? H && vt(
+            T(
               i,
-              P((B) => !B),
+              A((It) => !It),
               // skips the initial publish of false, and the cleanup call.
               // but if scrollingInProgress is true, we skip the initial publish.
-              jt(st(i) ? 1 : 2)
+              Kt(lt(i) ? 1 : 2)
             ),
-            b
-          ) : b && b(), nt;
-        }),
-        P((S) => S !== null)
-      ),
-      a
+            H
+          ) : H && H(), ut && G(u, ut);
+        }
+        L ? (h && (h(), h = null), h = vt(m, () => {
+          h = null, requestAnimationFrame(() => {
+            tt();
+          });
+        })) : tt();
+      }
     ), {
-      scrollIntoView: p
+      scrollIntoView: I
     };
   },
-  X(Et, at, ce, Dt, Vt),
+  Q(Bt, dt, ie, Nt, Vt),
   { singleton: !0 }
-), jn = U(
+), jn = $(
   ([{ scrollVelocity: t }]) => {
-    const e = C(!1), n = $(), o = C(!1);
+    const e = C(!1), n = D(), o = C(!1);
     return O(
-      x(
+      T(
         t,
         _(o, e, n),
-        P(([r, s]) => !!s),
-        E(([r, s, i, l]) => {
-          const { enter: c, exit: a } = s;
+        A(([r, s]) => !!s),
+        B(([r, s, i, l]) => {
+          const { enter: c, exit: u } = s;
           if (i) {
-            if (a(r, l))
+            if (u(r, l))
               return !1;
           } else if (c(r, l))
             return !0;
           return i;
         }),
-        Z()
+        J()
       ),
       e
-    ), K(
-      x(rt(e, t, n), _(o)),
+    ), j(
+      T(st(e, t, n), _(o)),
       ([[r, s, i], l]) => {
         r && l && l.change && l.change(s, i);
       }
     ), { isSeeking: e, scrollSeekConfiguration: o, scrollSeekRangeChanged: n, scrollVelocity: t };
   },
-  X(ae),
+  Q(ce),
   { singleton: !0 }
-), je = U(([{ scrollContainerState: t, scrollTo: e }]) => {
-  const n = $(), o = $(), r = $(), s = C(!1), i = C(void 0);
+), je = $(([{ scrollContainerState: t, scrollTo: e }]) => {
+  const n = D(), o = D(), r = D(), s = C(!1), i = C(void 0);
   return O(
-    x(
-      rt(n, o),
-      E(([{ scrollHeight: l, scrollTop: c, viewportHeight: a }, { offsetTop: p }]) => ({
+    T(
+      st(n, o),
+      B(([{ scrollHeight: l, scrollTop: c, viewportHeight: u }, { offsetTop: m }]) => ({
         scrollHeight: l,
-        scrollTop: Math.max(0, c - p),
-        viewportHeight: a
+        scrollTop: Math.max(0, c - m),
+        viewportHeight: u
       }))
     ),
     t
   ), O(
-    x(
+    T(
       e,
       _(o),
-      E(([l, { offsetTop: c }]) => ({
+      B(([l, { offsetTop: c }]) => ({
         ...l,
         top: l.top + c
       }))
@@ -1857,7 +1866,7 @@ const _o = (t, e) => typeof t == "function" ? xn(t(e)) : e && xn(t), No = U(
     windowScrollTo: r,
     windowViewportRect: o
   };
-}, X(at)), jo = U(
+}, Q(dt)), jo = $(
   ([
     { sizeRanges: t, sizes: e },
     { headerHeight: n, scrollTop: o },
@@ -1865,116 +1874,116 @@ const _o = (t, e) => typeof t == "function" ? xn(t(e)) : e && xn(t), No = U(
     { didMount: s },
     { useWindowScroll: i, windowScrollContainerState: l, windowViewportRect: c }
   ]) => {
-    const a = $(), p = C(void 0), S = C(null), g = C(null);
-    return O(l, S), O(c, g), K(
-      x(
-        a,
-        _(e, o, i, S, g, n)
+    const u = D(), m = C(void 0), I = C(null), h = C(null);
+    return O(l, I), O(c, h), j(
+      T(
+        u,
+        _(e, o, i, I, h, n)
       ),
-      ([h, w, v, m, d, u, T]) => {
+      ([p, w, y, f, d, a, S]) => {
         const R = Bo(w.sizeTree);
-        m && d !== null && u !== null && (v = d.scrollTop - u.offsetTop), v -= T, h({ ranges: R, scrollTop: v });
+        f && d !== null && a !== null && (y = d.scrollTop - a.offsetTop), y -= S, p({ ranges: R, scrollTop: y });
       }
-    ), O(x(p, P(Me), E(qo)), r), O(
-      x(
+    ), O(T(m, A(Me), B(qo)), r), O(
+      T(
         s,
-        _(p),
-        P(([, h]) => h !== void 0),
-        Z(),
-        E(([, h]) => h.ranges)
+        _(m),
+        A(([, p]) => p !== void 0),
+        J(),
+        B(([, p]) => p.ranges)
       ),
       t
     ), {
-      getState: a,
-      restoreStateFrom: p
+      getState: u,
+      restoreStateFrom: m
     };
   },
-  X(Et, at, ue, Pt, je)
+  Q(Bt, dt, le, Pt, je)
 );
 function qo(t) {
   return { align: "start", index: 0, offset: t.scrollTop };
 }
-const Yo = U(([{ topItemsIndexes: t }]) => {
+const Yo = $(([{ topItemsIndexes: t }]) => {
   const e = C(0);
   return O(
-    x(
+    T(
       e,
-      P((n) => n >= 0),
-      E((n) => Array.from({ length: n }).map((o, r) => r))
+      A((n) => n >= 0),
+      B((n) => Array.from({ length: n }).map((o, r) => r))
     ),
     t
   ), { topItemCount: e };
-}, X(Dt));
+}, Q(Nt));
 function qn(t) {
   let e = !1, n;
   return () => (e || (e = !0, n = t()), n);
 }
-const Zo = qn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent)), Xo = U(
+const Zo = qn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.test(navigator.userAgent)), Xo = $(
   ([
     { deviation: t, scrollBy: e, scrollingInProgress: n, scrollTop: o },
     { isAtBottom: r, isScrolling: s, lastJumpDueToItemResize: i, scrollDirection: l },
     { listState: c },
-    { beforeUnshiftWith: a, gap: p, shiftWithOffset: S, sizes: g },
-    { log: h },
+    { beforeUnshiftWith: u, gap: m, shiftWithOffset: I, sizes: h },
+    { log: p },
     { recalcInProgress: w }
   ]) => {
-    const v = ht(
-      x(
+    const y = gt(
+      T(
         c,
         _(i),
-        Rt(
-          ([, d, u, T], [{ bottom: R, items: I, offsetBottom: f, totalCount: b }, k]) => {
-            const F = R + f;
+        Ht(
+          ([, d, a, S], [{ bottom: R, items: g, offsetBottom: v, totalCount: x }, k]) => {
+            const H = R + v;
             let L = 0;
-            return u === b && d.length > 0 && I.length > 0 && (I[0].originalIndex === 0 && d[0].originalIndex === 0 || (L = F - T, L !== 0 && (L += k))), [L, I, b, F];
+            return a === x && d.length > 0 && g.length > 0 && (g[0].originalIndex === 0 && d[0].originalIndex === 0 || (L = H - S, L !== 0 && (L += k))), [L, g, x, H];
           },
           [0, [], 0, 0]
         ),
-        P(([d]) => d !== 0),
-        _(o, l, n, r, h, w),
-        P(([, d, u, T, , , R]) => !R && !T && d !== 0 && u === le),
-        E(([[d], , , , , u]) => (u("Upward scrolling compensation", { amount: d }, mt.DEBUG), d))
+        A(([d]) => d !== 0),
+        _(o, l, n, r, p, w),
+        A(([, d, a, S, , , R]) => !R && !S && d !== 0 && a === se),
+        B(([[d], , , , , a]) => (a("Upward scrolling compensation", { amount: d }, pt.DEBUG), d))
       )
     );
-    function m(d) {
+    function f(d) {
       d > 0 ? (G(e, { behavior: "auto", top: -d }), G(t, 0)) : (G(t, 0), G(e, { behavior: "auto", top: -d }));
     }
-    return K(x(v, _(t, s)), ([d, u, T]) => {
-      T && Zo() ? G(t, u - d) : m(-d);
-    }), K(
-      x(
-        rt(ct(s, !1), t, w),
-        P(([d, u, T]) => !d && !T && u !== 0),
-        E(([d, u]) => u),
+    return j(T(y, _(t, s)), ([d, a, S]) => {
+      S && Zo() ? G(t, a - d) : f(-d);
+    }), j(
+      T(
+        st(at(s, !1), t, w),
+        A(([d, a, S]) => !d && !S && a !== 0),
+        B(([d, a]) => a),
         Lt(1)
       ),
-      m
+      f
     ), O(
-      x(
-        S,
-        E((d) => ({ top: -d }))
+      T(
+        I,
+        B((d) => ({ top: -d }))
       ),
       e
-    ), K(
-      x(
-        a,
-        _(g, p),
-        E(([d, { groupIndices: u, lastSize: T, sizeTree: R }, I]) => {
-          function f(b) {
-            return b * (T + I);
+    ), j(
+      T(
+        u,
+        _(h, m),
+        B(([d, { groupIndices: a, lastSize: S, sizeTree: R }, g]) => {
+          function v(x) {
+            return x * (S + g);
           }
-          if (u.length === 0)
-            return f(d);
+          if (a.length === 0)
+            return v(d);
           {
-            let b = 0;
-            const k = re(R, 0);
-            let F = 0, L = 0;
-            for (; F < d; ) {
-              F++, b += k;
-              let V = u.length === L + 1 ? 1 / 0 : u[L + 1] - u[L] - 1;
-              F + V > d && (b -= k, V = d - F + 1), F += V, b += f(V), L++;
+            let x = 0;
+            const k = ne(R, 0);
+            let H = 0, L = 0;
+            for (; H < d; ) {
+              H++, x += k;
+              let z = a.length === L + 1 ? 1 / 0 : a[L + 1] - a[L] - 1;
+              H + z > d && (x -= k, z = d - H + 1), H += z, x += v(z), L++;
             }
-            return b;
+            return x;
           }
         })
       ),
@@ -1987,8 +1996,8 @@ const Zo = qn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.tes
       }
     ), { deviation: t };
   },
-  X(at, ae, Dt, Et, Vt, Ne)
-), Jo = U(
+  Q(dt, ce, Nt, Bt, Vt, Ne)
+), Jo = $(
   ([
     t,
     e,
@@ -1999,7 +2008,7 @@ const Zo = qn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.tes
     i,
     l,
     c,
-    a
+    u
   ]) => ({
     ...t,
     ...e,
@@ -2010,9 +2019,9 @@ const Zo = qn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.tes
     ...i,
     ...l,
     ...c,
-    ...a
+    ...u
   }),
-  X(
+  Q(
     Ke,
     Do,
     Pt,
@@ -2024,7 +2033,7 @@ const Zo = qn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.tes
     Ko,
     Vt
   )
-), Yn = U(
+), Yn = $(
   ([
     {
       data: t,
@@ -2036,26 +2045,26 @@ const Zo = qn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.tes
       itemSize: i,
       sizeRanges: l,
       sizes: c,
-      statefulTotalCount: a,
-      totalCount: p,
-      trackItemSizes: S
+      statefulTotalCount: u,
+      totalCount: m,
+      trackItemSizes: I
     },
-    { initialItemFinalLocationReached: g, initialTopMostItemIndex: h, scrolledToInitialItem: w },
-    v,
-    m,
-    d,
-    { listState: u, topItemsIndexes: T, ...R },
-    { scrollToIndex: I },
+    { initialItemFinalLocationReached: h, initialTopMostItemIndex: p, scrolledToInitialItem: w },
+    y,
     f,
-    { topItemCount: b },
+    d,
+    { listState: a, topItemsIndexes: S, ...R },
+    { scrollToIndex: g },
+    v,
+    { topItemCount: x },
     { groupCounts: k },
-    F
-  ]) => (O(R.rangeChanged, F.scrollSeekRangeChanged), O(
-    x(
-      F.windowViewportRect,
-      E((L) => L.visibleHeight)
+    H
+  ]) => (O(R.rangeChanged, H.scrollSeekRangeChanged), O(
+    T(
+      H.windowViewportRect,
+      B((L) => L.visibleHeight)
     ),
-    v.viewportHeight
+    y.viewportHeight
   ), {
     data: t,
     defaultItemHeight: e,
@@ -2063,38 +2072,38 @@ const Zo = qn(() => /iP(ad|od|hone)/i.test(navigator.userAgent) && /WebKit/i.tes
     fixedItemHeight: o,
     gap: r,
     groupCounts: k,
-    initialItemFinalLocationReached: g,
-    initialTopMostItemIndex: h,
+    initialItemFinalLocationReached: h,
+    initialTopMostItemIndex: p,
     scrolledToInitialItem: w,
     sizeRanges: l,
-    topItemCount: b,
-    topItemsIndexes: T,
+    topItemCount: x,
+    topItemsIndexes: S,
     // input
-    totalCount: p,
+    totalCount: m,
     ...d,
     groupIndices: s,
     itemSize: i,
-    listState: u,
-    scrollToIndex: I,
+    listState: a,
+    scrollToIndex: g,
     // output
-    statefulTotalCount: a,
-    trackItemSizes: S,
+    statefulTotalCount: u,
+    trackItemSizes: I,
     // exported from stateFlagsSystem
     ...R,
     // the bag of IO from featureGroup1System
-    ...F,
-    ...v,
+    ...H,
+    ...y,
     sizes: c,
-    ...m
+    ...f
   }),
-  X(
-    Et,
-    ue,
-    at,
+  Q(
+    Bt,
+    le,
+    dt,
     jo,
     No,
-    Dt,
-    ce,
+    Nt,
+    ie,
     Xo,
     Yo,
     Nn,
@@ -2111,140 +2120,140 @@ function Qo(t, e) {
     Object.hasOwn(o, i) || (n[i] = e[i]);
   return n;
 }
-const pe = typeof document < "u" ? H.useLayoutEffect : H.useEffect;
+const me = typeof document < "u" ? E.useLayoutEffect : E.useEffect;
 function qe(t, e, n) {
-  const o = Object.keys(e.required || {}), r = Object.keys(e.optional || {}), s = Object.keys(e.methods || {}), i = Object.keys(e.events || {}), l = H.createContext({});
-  function c(d, u) {
+  const o = Object.keys(e.required || {}), r = Object.keys(e.optional || {}), s = Object.keys(e.methods || {}), i = Object.keys(e.events || {}), l = E.createContext({});
+  function c(d, a) {
     d.propsReady && G(d.propsReady, !1);
-    for (const T of o) {
-      const R = d[e.required[T]];
-      G(R, u[T]);
+    for (const S of o) {
+      const R = d[e.required[S]];
+      G(R, a[S]);
     }
-    for (const T of r)
-      if (T in u) {
-        const R = d[e.optional[T]];
-        G(R, u[T]);
+    for (const S of r)
+      if (S in a) {
+        const R = d[e.optional[S]];
+        G(R, a[S]);
       }
     d.propsReady && G(d.propsReady, !0);
   }
-  function a(d) {
-    return s.reduce((u, T) => (u[T] = (R) => {
-      const I = d[e.methods[T]];
-      G(I, R);
-    }, u), {});
+  function u(d) {
+    return s.reduce((a, S) => (a[S] = (R) => {
+      const g = d[e.methods[S]];
+      G(g, R);
+    }, a), {});
   }
-  function p(d) {
-    return i.reduce((u, T) => (u[T] = ho(d[e.events[T]]), u), {});
+  function m(d) {
+    return i.reduce((a, S) => (a[S] = ho(d[e.events[S]]), a), {});
   }
-  const S = H.forwardRef((d, u) => {
-    const { children: T, ...R } = d, [I] = H.useState(() => ve(Io(t), (k) => {
+  const I = E.forwardRef((d, a) => {
+    const { children: S, ...R } = d, [g] = E.useState(() => we(Io(t), (k) => {
       c(k, R);
-    })), [f] = H.useState(un(p, I));
-    pe(() => {
+    })), [v] = E.useState(un(m, g));
+    me(() => {
       for (const k of i)
-        k in R && K(f[k], R[k]);
+        k in R && j(v[k], R[k]);
       return () => {
-        Object.values(f).map(We);
+        Object.values(v).map(We);
       };
-    }, [R, f, I]), pe(() => {
-      c(I, R);
-    }), H.useImperativeHandle(u, cn(a(I)));
-    const b = n;
-    return /* @__PURE__ */ z(l.Provider, { value: I, children: n ? /* @__PURE__ */ z(b, { ...Qo([...o, ...r, ...i], R), children: T }) : T });
-  }), g = (d) => {
-    const u = H.useContext(l);
-    return H.useCallback(
-      (T) => {
-        G(u[d], T);
+    }, [R, v, g]), me(() => {
+      c(g, R);
+    }), E.useImperativeHandle(a, cn(u(g)));
+    const x = n;
+    return /* @__PURE__ */ V(l.Provider, { value: g, children: n ? /* @__PURE__ */ V(x, { ...Qo([...o, ...r, ...i], R), children: S }) : S });
+  }), h = (d) => {
+    const a = E.useContext(l);
+    return E.useCallback(
+      (S) => {
+        G(a[d], S);
       },
-      [u, d]
+      [a, d]
     );
-  }, h = (d) => {
-    const T = H.useContext(l)[d], R = H.useCallback(
-      (I) => K(T, I),
-      [T]
+  }, p = (d) => {
+    const S = E.useContext(l)[d], R = E.useCallback(
+      (g) => j(S, g),
+      [S]
     );
-    return H.useSyncExternalStore(
+    return E.useSyncExternalStore(
       R,
-      () => st(T),
-      () => st(T)
+      () => lt(S),
+      () => lt(S)
     );
   }, w = (d) => {
-    const T = H.useContext(l)[d], [R, I] = H.useState(un(st, T));
-    return pe(
-      () => K(T, (f) => {
-        f !== R && I(cn(f));
+    const S = E.useContext(l)[d], [R, g] = E.useState(un(lt, S));
+    return me(
+      () => j(S, (v) => {
+        v !== R && g(cn(v));
       }),
-      [T, R]
+      [S, R]
     ), R;
-  }, v = H.version.startsWith("18") ? h : w;
+  }, y = E.version.startsWith("18") ? p : w;
   return {
-    Component: S,
-    useEmitter: (d, u) => {
-      const R = H.useContext(l)[d];
-      pe(() => K(R, u), [u, R]);
+    Component: I,
+    useEmitter: (d, a) => {
+      const R = E.useContext(l)[d];
+      me(() => j(R, a), [a, R]);
     },
-    useEmitterValue: v,
-    usePublisher: g
+    useEmitterValue: y,
+    usePublisher: h
   };
 }
-const be = H.createContext(void 0), Zn = H.createContext(void 0), Xn = typeof document < "u" ? H.useLayoutEffect : H.useEffect;
+const Re = E.createContext(void 0), Zn = E.createContext(void 0), Xn = typeof document < "u" ? E.useLayoutEffect : E.useEffect;
 function ke(t) {
   return "self" in t;
 }
 function tr(t) {
   return "body" in t;
 }
-function Jn(t, e, n, o = Yt, r, s) {
-  const i = H.useRef(null), l = H.useRef(null), c = H.useRef(null), a = H.useCallback(
-    (g) => {
-      let h, w, v;
-      const m = g.target;
-      if (tr(m) || ke(m)) {
-        const u = ke(m) ? m : m.defaultView;
-        v = s ? u.scrollX : u.scrollY, h = s ? u.document.documentElement.scrollWidth : u.document.documentElement.scrollHeight, w = s ? u.innerWidth : u.innerHeight;
+function Jn(t, e, n, o = qt, r, s) {
+  const i = E.useRef(null), l = E.useRef(null), c = E.useRef(null), u = E.useCallback(
+    (h) => {
+      let p, w, y;
+      const f = h.target;
+      if (tr(f) || ke(f)) {
+        const a = ke(f) ? f : f.defaultView;
+        y = s ? a.scrollX : a.scrollY, p = s ? a.document.documentElement.scrollWidth : a.document.documentElement.scrollHeight, w = s ? a.innerWidth : a.innerHeight;
       } else
-        v = s ? m.scrollLeft : m.scrollTop, h = s ? m.scrollWidth : m.scrollHeight, w = s ? m.offsetWidth : m.offsetHeight;
+        y = s ? f.scrollLeft : f.scrollTop, p = s ? f.scrollWidth : f.scrollHeight, w = s ? f.offsetWidth : f.offsetHeight;
       const d = () => {
         t({
-          scrollHeight: h,
-          scrollTop: Math.max(v, 0),
+          scrollHeight: p,
+          scrollTop: Math.max(y, 0),
           viewportHeight: w
         });
       };
-      g.suppressFlushSync ? d() : co.flushSync(d), l.current !== null && (v === l.current || v <= 0 || v === h - w) && (l.current = null, e(!0), c.current && (clearTimeout(c.current), c.current = null));
+      h.suppressFlushSync ? d() : co.flushSync(d), l.current !== null && (y === l.current || y <= 0 || y === p - w) && (l.current = null, e(!0), c.current && (clearTimeout(c.current), c.current = null));
     },
     [t, e, s]
   );
-  H.useEffect(() => {
-    const g = r || i.current;
-    return o(r || i.current), a({ suppressFlushSync: !0, target: g }), g.addEventListener("scroll", a, { passive: !0 }), () => {
-      o(null), g.removeEventListener("scroll", a);
+  E.useEffect(() => {
+    const h = r || i.current;
+    return o(r || i.current), u({ suppressFlushSync: !0, target: h }), h.addEventListener("scroll", u, { passive: !0 }), () => {
+      o(null), h.removeEventListener("scroll", u);
     };
-  }, [i, a, n, o, r]);
-  function p(g) {
-    const h = i.current;
-    if (!h || (s ? "offsetWidth" in h && h.offsetWidth === 0 : "offsetHeight" in h && h.offsetHeight === 0))
+  }, [i, u, n, o, r]);
+  function m(h) {
+    const p = i.current;
+    if (!p || (s ? "offsetWidth" in p && p.offsetWidth === 0 : "offsetHeight" in p && p.offsetHeight === 0))
       return;
-    const w = g.behavior === "smooth";
-    let v, m, d;
-    ke(h) ? (m = Math.max(
-      wt(h.document.documentElement, s ? "width" : "height"),
-      s ? h.document.documentElement.scrollWidth : h.document.documentElement.scrollHeight
-    ), v = s ? h.innerWidth : h.innerHeight, d = s ? window.scrollX : window.scrollY) : (m = h[s ? "scrollWidth" : "scrollHeight"], v = wt(h, s ? "width" : "height"), d = h[s ? "scrollLeft" : "scrollTop"]);
-    const u = m - v;
-    if (g.top = Math.ceil(Math.max(Math.min(u, g.top), 0)), $n(v, m) || g.top === d) {
-      t({ scrollHeight: m, scrollTop: d, viewportHeight: v }), w && e(!0);
+    const w = h.behavior === "smooth";
+    let y, f, d;
+    ke(p) ? (f = Math.max(
+      Rt(p.document.documentElement, s ? "width" : "height"),
+      s ? p.document.documentElement.scrollWidth : p.document.documentElement.scrollHeight
+    ), y = s ? p.innerWidth : p.innerHeight, d = s ? window.scrollX : window.scrollY) : (f = p[s ? "scrollWidth" : "scrollHeight"], y = Rt(p, s ? "width" : "height"), d = p[s ? "scrollLeft" : "scrollTop"]);
+    const a = f - y;
+    if (h.top = Math.ceil(Math.max(Math.min(a, h.top), 0)), $n(y, f) || h.top === d) {
+      t({ scrollHeight: f, scrollTop: d, viewportHeight: y }), w && e(!0);
       return;
     }
-    w ? (l.current = g.top, c.current && clearTimeout(c.current), c.current = setTimeout(() => {
+    w ? (l.current = h.top, c.current && clearTimeout(c.current), c.current = setTimeout(() => {
       c.current = null, l.current = null, e(!0);
-    }, 1e3)) : l.current = null, s && (g = { behavior: g.behavior, left: g.top }), h.scrollTo(g);
+    }, 1e3)) : l.current = null, s && (h = { behavior: h.behavior, left: h.top }), p.scrollTo(h);
   }
-  function S(g) {
-    s && (g = { behavior: g.behavior, left: g.top }), i.current.scrollBy(g);
+  function I(h) {
+    s && (h = { behavior: h.behavior, left: h.top }), i.current.scrollBy(h);
   }
-  return { scrollByCallback: S, scrollerRef: i, scrollToCallback: p };
+  return { scrollByCallback: I, scrollerRef: i, scrollToCallback: m };
 }
 const Fe = "-webkit-sticky", Tn = "sticky", Ye = qn(() => {
   if (typeof document > "u")
@@ -2255,14 +2264,14 @@ const Fe = "-webkit-sticky", Tn = "sticky", Ye = qn(() => {
 function Ze(t) {
   return t;
 }
-const er = /* @__PURE__ */ U(() => {
-  const t = C((c) => `Item ${c}`), e = C(null), n = C((c) => `Group ${c}`), o = C({}), r = C(Ze), s = C("div"), i = C(Yt), l = (c, a = null) => ct(
-    x(
+const er = /* @__PURE__ */ $(() => {
+  const t = C((c) => `Item ${c}`), e = C(null), n = C((c) => `Group ${c}`), o = C({}), r = C(Ze), s = C("div"), i = C(qt), l = (c, u = null) => at(
+    T(
       o,
-      E((p) => p[c]),
-      Z()
+      B((m) => m[c]),
+      J()
     ),
-    a
+    u
   );
   return {
     components: o,
@@ -2282,83 +2291,83 @@ const er = /* @__PURE__ */ U(() => {
     ScrollSeekPlaceholder: l("ScrollSeekPlaceholder"),
     TopItemListComponent: l("TopItemList")
   };
-}), nr = /* @__PURE__ */ U(
+}), nr = /* @__PURE__ */ $(
   ([t, e]) => ({ ...t, ...e }),
-  X(Yn, er)
-), or = ({ height: t }) => /* @__PURE__ */ z("div", { style: { height: t } }), rr = { overflowAnchor: "none", position: Ye(), zIndex: 1 }, Qn = { overflowAnchor: "none" }, sr = { ...Qn, display: "inline-block", height: "100%" }, Cn = /* @__PURE__ */ H.memo(function({ showTopList: e = !1 }) {
-  const n = M("listState"), o = gt("sizeRanges"), r = M("useWindowScroll"), s = M("customScrollParent"), i = gt("windowScrollContainerState"), l = gt("scrollContainerState"), c = s || r ? i : l, a = M("itemContent"), p = M("context"), S = M("groupContent"), g = M("trackItemSizes"), h = M("itemSize"), w = M("log"), v = gt("gap"), m = M("horizontalDirection"), { callbackRef: d } = On(
+  Q(Yn, er)
+), or = ({ height: t }) => /* @__PURE__ */ V("div", { style: { height: t } }), rr = { overflowAnchor: "none", position: Ye(), zIndex: 1 }, Qn = { overflowAnchor: "none" }, sr = { ...Qn, display: "inline-block", height: "100%" }, Cn = /* @__PURE__ */ E.memo(function({ showTopList: e = !1 }) {
+  const n = M("listState"), o = Tt("sizeRanges"), r = M("useWindowScroll"), s = M("customScrollParent"), i = Tt("windowScrollContainerState"), l = Tt("scrollContainerState"), c = s || r ? i : l, u = M("itemContent"), m = M("context"), I = M("groupContent"), h = M("trackItemSizes"), p = M("itemSize"), w = M("log"), y = Tt("gap"), f = M("horizontalDirection"), { callbackRef: d } = On(
     o,
+    p,
     h,
-    g,
-    e ? Yt : c,
+    e ? qt : c,
     w,
-    v,
+    y,
     s,
-    m,
+    f,
     M("skipAnimationFrameInResizeObserver")
-  ), [u, T] = H.useState(0);
-  Qe("deviation", (B) => {
-    u !== B && T(B);
+  ), [a, S] = E.useState(0);
+  Qe("deviation", (F) => {
+    a !== F && S(F);
   });
-  const R = M("EmptyPlaceholder"), I = M("ScrollSeekPlaceholder") || or, f = M("ListComponent"), b = M("ItemComponent"), k = M("GroupComponent"), F = M("computeItemKey"), L = M("isSeeking"), V = M("groupIndices").length > 0, D = M("alignToBottom"), J = M("initialItemFinalLocationReached"), nt = e ? {} : {
+  const R = M("EmptyPlaceholder"), g = M("ScrollSeekPlaceholder") || or, v = M("ListComponent"), x = M("ItemComponent"), k = M("GroupComponent"), H = M("computeItemKey"), L = M("isSeeking"), z = M("groupIndices").length > 0, U = M("alignToBottom"), q = M("initialItemFinalLocationReached"), ct = e ? {} : {
     boxSizing: "border-box",
-    ...m ? {
+    ...f ? {
       display: "inline-block",
       height: "100%",
-      marginLeft: u !== 0 ? u : D ? "auto" : 0,
+      marginLeft: a !== 0 ? a : U ? "auto" : 0,
       paddingLeft: n.offsetTop,
       paddingRight: n.offsetBottom,
       whiteSpace: "nowrap"
     } : {
-      marginTop: u !== 0 ? u : D ? "auto" : 0,
+      marginTop: a !== 0 ? a : U ? "auto" : 0,
       paddingBottom: n.offsetBottom,
       paddingTop: n.offsetTop
     },
-    ...J ? {} : { visibility: "hidden" }
+    ...q ? {} : { visibility: "hidden" }
   };
-  return !e && n.totalCount === 0 && R ? /* @__PURE__ */ z(R, { ...q(R, p) }) : /* @__PURE__ */ z(
-    f,
+  return !e && n.totalCount === 0 && R ? /* @__PURE__ */ V(R, { ...X(R, m) }) : /* @__PURE__ */ V(
+    v,
     {
-      ...q(f, p),
+      ...X(v, m),
       "data-testid": e ? "virtuoso-top-item-list" : "virtuoso-item-list",
       ref: d,
-      style: nt,
-      children: (e ? n.topItems : n.items).map((B) => {
-        const Y = B.originalIndex, it = F(Y + n.firstItemIndex, B.data, p);
-        return L ? /* @__PURE__ */ _t(
-          I,
+      style: ct,
+      children: (e ? n.topItems : n.items).map((F) => {
+        const K = F.originalIndex, tt = H(K + n.firstItemIndex, F.data, m);
+        return L ? /* @__PURE__ */ Gt(
+          g,
           {
-            ...q(I, p),
-            height: B.size,
-            index: B.index,
-            key: it,
-            type: B.type || "item",
-            ...B.type === "group" ? {} : { groupIndex: B.groupIndex }
+            ...X(g, m),
+            height: F.size,
+            index: F.index,
+            key: tt,
+            type: F.type || "item",
+            ...F.type === "group" ? {} : { groupIndex: F.groupIndex }
           }
-        ) : B.type === "group" ? /* @__PURE__ */ _t(
+        ) : F.type === "group" ? /* @__PURE__ */ Gt(
           k,
           {
-            ...q(k, p),
-            "data-index": Y,
-            "data-item-index": B.index,
-            "data-known-size": B.size,
-            key: it,
+            ...X(k, m),
+            "data-index": K,
+            "data-item-index": F.index,
+            "data-known-size": F.size,
+            key: tt,
             style: rr
           },
-          S(B.index, p)
-        ) : /* @__PURE__ */ _t(
-          b,
+          I(F.index, m)
+        ) : /* @__PURE__ */ Gt(
+          x,
           {
-            ...q(b, p),
-            ...to(b, B.data),
-            "data-index": Y,
-            "data-item-group-index": B.groupIndex,
-            "data-item-index": B.index,
-            "data-known-size": B.size,
-            key: it,
-            style: m ? sr : Qn
+            ...X(x, m),
+            ...to(x, F.data),
+            "data-index": K,
+            "data-item-group-index": F.groupIndex,
+            "data-item-index": F.index,
+            "data-known-size": F.size,
+            key: tt,
+            style: f ? sr : Qn
           },
-          V ? a(B.index, B.groupIndex, B.data, p) : a(B.index, B.data, p)
+          z ? u(F.index, F.groupIndex, F.data, m) : u(F.index, F.data, m)
         );
       })
     }
@@ -2373,7 +2382,7 @@ const er = /* @__PURE__ */ U(() => {
   outline: "none",
   overflowX: "auto",
   position: "relative"
-}, Zt = (t) => ({
+}, Yt = (t) => ({
   height: "100%",
   position: "absolute",
   top: 0,
@@ -2385,125 +2394,125 @@ const er = /* @__PURE__ */ U(() => {
   width: "100%",
   zIndex: 1
 };
-function q(t, e) {
+function X(t, e) {
   if (typeof t != "string")
     return { context: e };
 }
 function to(t, e) {
   return { item: typeof t == "string" ? void 0 : e };
 }
-const ur = /* @__PURE__ */ H.memo(function() {
-  const e = M("HeaderComponent"), n = gt("headerHeight"), o = M("HeaderFooterTag"), r = Ht(
-    H.useMemo(
+const ur = /* @__PURE__ */ E.memo(function() {
+  const e = M("HeaderComponent"), n = Tt("headerHeight"), o = M("HeaderFooterTag"), r = Et(
+    E.useMemo(
       () => (i) => {
-        n(wt(i, "height"));
+        n(Rt(i, "height"));
       },
       [n]
     ),
     !0,
     M("skipAnimationFrameInResizeObserver")
   ), s = M("context");
-  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...q(e, s) }) }) : null;
-}), ar = /* @__PURE__ */ H.memo(function() {
-  const e = M("FooterComponent"), n = gt("footerHeight"), o = M("HeaderFooterTag"), r = Ht(
-    H.useMemo(
+  return e ? /* @__PURE__ */ V(o, { ref: r, children: /* @__PURE__ */ V(e, { ...X(e, s) }) }) : null;
+}), ar = /* @__PURE__ */ E.memo(function() {
+  const e = M("FooterComponent"), n = Tt("footerHeight"), o = M("HeaderFooterTag"), r = Et(
+    E.useMemo(
       () => (i) => {
-        n(wt(i, "height"));
+        n(Rt(i, "height"));
       },
       [n]
     ),
     !0,
     M("skipAnimationFrameInResizeObserver")
   ), s = M("context");
-  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...q(e, s) }) }) : null;
+  return e ? /* @__PURE__ */ V(o, { ref: r, children: /* @__PURE__ */ V(e, { ...X(e, s) }) }) : null;
 });
 function Xe({ useEmitter: t, useEmitterValue: e, usePublisher: n }) {
-  return H.memo(function({ children: s, style: i, ...l }) {
-    const c = n("scrollContainerState"), a = e("ScrollerComponent"), p = n("smoothScrollTargetReached"), S = e("scrollerRef"), g = e("context"), h = e("horizontalDirection") || !1, { scrollByCallback: w, scrollerRef: v, scrollToCallback: m } = Jn(
+  return E.memo(function({ children: s, style: i, ...l }) {
+    const c = n("scrollContainerState"), u = e("ScrollerComponent"), m = n("smoothScrollTargetReached"), I = e("scrollerRef"), h = e("context"), p = e("horizontalDirection") || !1, { scrollByCallback: w, scrollerRef: y, scrollToCallback: f } = Jn(
       c,
-      p,
-      a,
-      S,
+      m,
+      u,
+      I,
       void 0,
-      h
+      p
     );
-    return t("scrollTo", m), t("scrollBy", w), /* @__PURE__ */ z(
-      a,
+    return t("scrollTo", f), t("scrollBy", w), /* @__PURE__ */ V(
+      u,
       {
         "data-testid": "virtuoso-scroller",
         "data-virtuoso-scroller": !0,
-        ref: v,
-        style: { ...h ? lr : ir, ...i },
+        ref: y,
+        style: { ...p ? lr : ir, ...i },
         tabIndex: 0,
         ...l,
-        ...q(a, g),
+        ...X(u, h),
         children: s
       }
     );
   });
 }
 function Je({ useEmitter: t, useEmitterValue: e, usePublisher: n }) {
-  return H.memo(function({ children: s, style: i, ...l }) {
-    const c = n("windowScrollContainerState"), a = e("ScrollerComponent"), p = n("smoothScrollTargetReached"), S = e("totalListHeight"), g = e("deviation"), h = e("customScrollParent"), w = e("context"), v = H.useRef(null), m = e("scrollerRef"), { scrollByCallback: d, scrollerRef: u, scrollToCallback: T } = Jn(
+  return E.memo(function({ children: s, style: i, ...l }) {
+    const c = n("windowScrollContainerState"), u = e("ScrollerComponent"), m = n("smoothScrollTargetReached"), I = e("totalListHeight"), h = e("deviation"), p = e("customScrollParent"), w = e("context"), y = E.useRef(null), f = e("scrollerRef"), { scrollByCallback: d, scrollerRef: a, scrollToCallback: S } = Jn(
       c,
-      p,
-      a,
       m,
-      h
+      u,
+      f,
+      p
     );
     return Xn(() => {
       var R;
-      return u.current = h || ((R = v.current) == null ? void 0 : R.ownerDocument.defaultView), () => {
-        u.current = null;
+      return a.current = p || ((R = y.current) == null ? void 0 : R.ownerDocument.defaultView), () => {
+        a.current = null;
       };
-    }, [u, h]), t("windowScrollTo", T), t("scrollBy", d), /* @__PURE__ */ z(
-      a,
+    }, [a, p]), t("windowScrollTo", S), t("scrollBy", d), /* @__PURE__ */ V(
+      u,
       {
-        ref: v,
+        ref: y,
         "data-virtuoso-scroller": !0,
-        style: { position: "relative", ...i, ...S !== 0 ? { height: S + g } : {} },
+        style: { position: "relative", ...i, ...I !== 0 ? { height: I + h } : {} },
         ...l,
-        ...q(a, w),
+        ...X(u, w),
         children: s
       }
     );
   });
 }
 const dr = ({ children: t }) => {
-  const e = H.useContext(be), n = gt("viewportHeight"), o = gt("fixedItemHeight"), r = M("alignToBottom"), s = M("horizontalDirection"), i = H.useMemo(
-    () => ne(n, (c) => wt(c, s ? "width" : "height")),
+  const e = E.useContext(Re), n = Tt("viewportHeight"), o = Tt("fixedItemHeight"), r = M("alignToBottom"), s = M("horizontalDirection"), i = E.useMemo(
+    () => te(n, (c) => Rt(c, s ? "width" : "height")),
     [n, s]
-  ), l = Ht(i, !0, M("skipAnimationFrameInResizeObserver"));
-  return H.useEffect(() => {
+  ), l = Et(i, !0, M("skipAnimationFrameInResizeObserver"));
+  return E.useEffect(() => {
     e && (n(e.viewportHeight), o(e.itemHeight));
-  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "element", ref: l, style: Zt(r), children: t });
+  }, [e, n, o]), /* @__PURE__ */ V("div", { "data-viewport-type": "element", ref: l, style: Yt(r), children: t });
 }, fr = ({ children: t }) => {
-  const e = H.useContext(be), n = gt("windowViewportRect"), o = gt("fixedItemHeight"), r = M("customScrollParent"), s = _e(
+  const e = E.useContext(Re), n = Tt("windowViewportRect"), o = Tt("fixedItemHeight"), r = M("customScrollParent"), s = _e(
     n,
     r,
     M("skipAnimationFrameInResizeObserver")
   ), i = M("alignToBottom");
-  return H.useEffect(() => {
+  return E.useEffect(() => {
     e && (o(e.itemHeight), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: 100 }));
-  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "window", ref: s, style: Zt(i), children: t });
+  }, [e, n, o]), /* @__PURE__ */ V("div", { "data-viewport-type": "window", ref: s, style: Yt(i), children: t });
 }, mr = ({ children: t }) => {
   const e = M("TopItemListComponent") || "div", n = M("headerHeight"), o = { ...cr, marginTop: `${n}px` }, r = M("context");
-  return /* @__PURE__ */ z(e, { style: o, ...q(e, r), children: t });
-}, pr = /* @__PURE__ */ H.memo(function(e) {
+  return /* @__PURE__ */ V(e, { style: o, ...X(e, r), children: t });
+}, pr = /* @__PURE__ */ E.memo(function(e) {
   const n = M("useWindowScroll"), o = M("topItemsIndexes").length > 0, r = M("customScrollParent"), s = M("context"), i = r || n ? gr : hr, l = r || n ? fr : dr;
-  return /* @__PURE__ */ Nt(i, { ...e, ...q(i, s), children: [
-    o && /* @__PURE__ */ z(mr, { children: /* @__PURE__ */ z(Cn, { showTopList: !0 }) }),
-    /* @__PURE__ */ Nt(l, { children: [
-      /* @__PURE__ */ z(ur, {}),
-      /* @__PURE__ */ z(Cn, {}),
-      /* @__PURE__ */ z(ar, {})
+  return /* @__PURE__ */ _t(i, { ...e, ...X(i, s), children: [
+    o && /* @__PURE__ */ V(mr, { children: /* @__PURE__ */ V(Cn, { showTopList: !0 }) }),
+    /* @__PURE__ */ _t(l, { children: [
+      /* @__PURE__ */ V(ur, {}),
+      /* @__PURE__ */ V(Cn, {}),
+      /* @__PURE__ */ V(ar, {})
     ] })
   ] });
 }), {
   Component: eo,
   useEmitter: Qe,
   useEmitterValue: M,
-  usePublisher: gt
+  usePublisher: Tt
 } = /* @__PURE__ */ qe(
   nr,
   {
@@ -2562,20 +2571,20 @@ const dr = ({ children: t }) => {
     }
   },
   pr
-), hr = /* @__PURE__ */ Xe({ useEmitter: Qe, useEmitterValue: M, usePublisher: gt }), gr = /* @__PURE__ */ Je({ useEmitter: Qe, useEmitterValue: M, usePublisher: gt }), jr = eo, qr = eo, Ir = /* @__PURE__ */ U(() => {
-  const t = C((a) => /* @__PURE__ */ Nt("td", { children: [
+), hr = /* @__PURE__ */ Xe({ useEmitter: Qe, useEmitterValue: M, usePublisher: Tt }), gr = /* @__PURE__ */ Je({ useEmitter: Qe, useEmitterValue: M, usePublisher: Tt }), jr = eo, qr = eo, Ir = /* @__PURE__ */ $(() => {
+  const t = C((u) => /* @__PURE__ */ _t("td", { children: [
     "Item $",
-    a
-  ] })), e = C(null), n = C((a) => /* @__PURE__ */ Nt("td", { colSpan: 1e3, children: [
+    u
+  ] })), e = C(null), n = C((u) => /* @__PURE__ */ _t("td", { colSpan: 1e3, children: [
     "Group ",
-    a
-  ] })), o = C(null), r = C(null), s = C({}), i = C(Ze), l = C(Yt), c = (a, p = null) => ct(
-    x(
+    u
+  ] })), o = C(null), r = C(null), s = C({}), i = C(Ze), l = C(qt), c = (u, m = null) => at(
+    T(
       s,
-      E((S) => S[a]),
-      Z()
+      B((I) => I[u]),
+      J()
     ),
-    p
+    m
   );
   return {
     components: s,
@@ -2597,132 +2606,132 @@ const dr = ({ children: t }) => {
     TableRowComponent: c("TableRow", "tr"),
     GroupComponent: c("Group", "tr")
   };
-}), Sr = /* @__PURE__ */ U(
+}), Sr = /* @__PURE__ */ $(
   ([t, e]) => ({ ...t, ...e }),
-  X(Yn, Ir)
-), xr = ({ height: t }) => /* @__PURE__ */ z("tr", { children: /* @__PURE__ */ z("td", { style: { height: t } }) }), Tr = ({ height: t }) => /* @__PURE__ */ z("tr", { children: /* @__PURE__ */ z("td", { style: { border: 0, height: t, padding: 0 } }) }), Cr = { overflowAnchor: "none" }, wn = { position: Ye(), zIndex: 2, overflowAnchor: "none" }, vn = /* @__PURE__ */ H.memo(function({ showTopList: e = !1 }) {
-  const n = W("listState"), o = W("computeItemKey"), r = W("firstItemIndex"), s = W("context"), i = W("isSeeking"), l = W("fixedHeaderHeight"), c = W("groupIndices").length > 0, a = W("itemContent"), p = W("groupContent"), S = W("ScrollSeekPlaceholder") || xr, g = W("GroupComponent"), h = W("TableRowComponent"), w = (e ? n.topItems : []).reduce((m, d, u) => (u === 0 ? m.push(d.size) : m.push(m[u - 1] + d.size), m), []), v = (e ? n.topItems : n.items).map((m) => {
-    const d = m.originalIndex, u = o(d + r, m.data, s), T = e ? d === 0 ? 0 : w[d - 1] : 0;
-    return i ? /* @__PURE__ */ _t(
-      S,
+  Q(Yn, Ir)
+), xr = ({ height: t }) => /* @__PURE__ */ V("tr", { children: /* @__PURE__ */ V("td", { style: { height: t } }) }), Tr = ({ height: t }) => /* @__PURE__ */ V("tr", { children: /* @__PURE__ */ V("td", { style: { border: 0, height: t, padding: 0 } }) }), Cr = { overflowAnchor: "none" }, wn = { position: Ye(), zIndex: 2, overflowAnchor: "none" }, vn = /* @__PURE__ */ E.memo(function({ showTopList: e = !1 }) {
+  const n = W("listState"), o = W("computeItemKey"), r = W("firstItemIndex"), s = W("context"), i = W("isSeeking"), l = W("fixedHeaderHeight"), c = W("groupIndices").length > 0, u = W("itemContent"), m = W("groupContent"), I = W("ScrollSeekPlaceholder") || xr, h = W("GroupComponent"), p = W("TableRowComponent"), w = (e ? n.topItems : []).reduce((f, d, a) => (a === 0 ? f.push(d.size) : f.push(f[a - 1] + d.size), f), []), y = (e ? n.topItems : n.items).map((f) => {
+    const d = f.originalIndex, a = o(d + r, f.data, s), S = e ? d === 0 ? 0 : w[d - 1] : 0;
+    return i ? /* @__PURE__ */ Gt(
+      I,
       {
-        ...q(S, s),
-        height: m.size,
-        index: m.index,
-        key: u,
-        type: m.type || "item"
+        ...X(I, s),
+        height: f.size,
+        index: f.index,
+        key: a,
+        type: f.type || "item"
       }
-    ) : m.type === "group" ? /* @__PURE__ */ _t(
-      g,
+    ) : f.type === "group" ? /* @__PURE__ */ Gt(
+      h,
       {
-        ...q(g, s),
+        ...X(h, s),
         "data-index": d,
-        "data-item-index": m.index,
-        "data-known-size": m.size,
-        key: u,
+        "data-item-index": f.index,
+        "data-known-size": f.size,
+        key: a,
         style: {
           ...wn,
           top: l
         }
       },
-      p(m.index, s)
-    ) : /* @__PURE__ */ _t(
-      h,
+      m(f.index, s)
+    ) : /* @__PURE__ */ Gt(
+      p,
       {
-        ...q(h, s),
-        ...to(h, m.data),
+        ...X(p, s),
+        ...to(p, f.data),
         "data-index": d,
-        "data-item-index": m.index,
-        "data-known-size": m.size,
-        "data-item-group-index": m.groupIndex,
-        key: u,
-        style: e ? { ...wn, top: l + T } : Cr
+        "data-item-index": f.index,
+        "data-known-size": f.size,
+        "data-item-group-index": f.groupIndex,
+        key: a,
+        style: e ? { ...wn, top: l + S } : Cr
       },
-      c ? a(m.index, m.groupIndex, m.data, s) : a(m.index, m.data, s)
+      c ? u(f.index, f.groupIndex, f.data, s) : u(f.index, f.data, s)
     );
   });
-  return /* @__PURE__ */ z(lo, { children: v });
-}), wr = /* @__PURE__ */ H.memo(function() {
-  const e = W("listState"), n = W("topItemsIndexes").length > 0, o = Tt("sizeRanges"), r = W("useWindowScroll"), s = W("customScrollParent"), i = Tt("windowScrollContainerState"), l = Tt("scrollContainerState"), c = s || r ? i : l, a = W("trackItemSizes"), p = W("itemSize"), S = W("log"), { callbackRef: g, ref: h } = On(
+  return /* @__PURE__ */ V(lo, { children: y });
+}), wr = /* @__PURE__ */ E.memo(function() {
+  const e = W("listState"), n = W("topItemsIndexes").length > 0, o = wt("sizeRanges"), r = W("useWindowScroll"), s = W("customScrollParent"), i = wt("windowScrollContainerState"), l = wt("scrollContainerState"), c = s || r ? i : l, u = W("trackItemSizes"), m = W("itemSize"), I = W("log"), { callbackRef: h, ref: p } = On(
     o,
-    p,
-    a,
+    m,
+    u,
     c,
-    S,
+    I,
     void 0,
     s,
     !1,
     W("skipAnimationFrameInResizeObserver")
-  ), [w, v] = H.useState(0);
-  tn("deviation", (V) => {
-    w !== V && (h.current.style.marginTop = `${V}px`, v(V));
+  ), [w, y] = E.useState(0);
+  tn("deviation", (z) => {
+    w !== z && (p.current.style.marginTop = `${z}px`, y(z));
   });
-  const m = W("EmptyPlaceholder"), d = W("FillerRow") || Tr, u = W("TableBodyComponent"), T = W("paddingTopAddition"), R = W("statefulTotalCount"), I = W("context");
-  if (R === 0 && m)
-    return /* @__PURE__ */ z(m, { ...q(m, I) });
-  const f = (n ? e.topItems : []).reduce((V, D) => V + D.size, 0), b = e.offsetTop + T + w - f, k = e.offsetBottom, F = b > 0 ? /* @__PURE__ */ z(d, { context: I, height: b }, "padding-top") : null, L = k > 0 ? /* @__PURE__ */ z(d, { context: I, height: k }, "padding-bottom") : null;
-  return /* @__PURE__ */ Nt(u, { "data-testid": "virtuoso-item-list", ref: g, ...q(u, I), children: [
-    F,
-    n && /* @__PURE__ */ z(vn, { showTopList: !0 }),
-    /* @__PURE__ */ z(vn, {}),
+  const f = W("EmptyPlaceholder"), d = W("FillerRow") || Tr, a = W("TableBodyComponent"), S = W("paddingTopAddition"), R = W("statefulTotalCount"), g = W("context");
+  if (R === 0 && f)
+    return /* @__PURE__ */ V(f, { ...X(f, g) });
+  const v = (n ? e.topItems : []).reduce((z, U) => z + U.size, 0), x = e.offsetTop + S + w - v, k = e.offsetBottom, H = x > 0 ? /* @__PURE__ */ V(d, { context: g, height: x }, "padding-top") : null, L = k > 0 ? /* @__PURE__ */ V(d, { context: g, height: k }, "padding-bottom") : null;
+  return /* @__PURE__ */ _t(a, { "data-testid": "virtuoso-item-list", ref: h, ...X(a, g), children: [
+    H,
+    n && /* @__PURE__ */ V(vn, { showTopList: !0 }),
+    /* @__PURE__ */ V(vn, {}),
     L
   ] });
 }), vr = ({ children: t }) => {
-  const e = H.useContext(be), n = Tt("viewportHeight"), o = Tt("fixedItemHeight"), r = Ht(
-    H.useMemo(() => ne(n, (s) => wt(s, "height")), [n]),
+  const e = E.useContext(Re), n = wt("viewportHeight"), o = wt("fixedItemHeight"), r = Et(
+    E.useMemo(() => te(n, (s) => Rt(s, "height")), [n]),
     !0,
     W("skipAnimationFrameInResizeObserver")
   );
-  return H.useEffect(() => {
+  return E.useEffect(() => {
     e && (n(e.viewportHeight), o(e.itemHeight));
-  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "element", ref: r, style: Zt(!1), children: t });
+  }, [e, n, o]), /* @__PURE__ */ V("div", { "data-viewport-type": "element", ref: r, style: Yt(!1), children: t });
 }, yr = ({ children: t }) => {
-  const e = H.useContext(be), n = Tt("windowViewportRect"), o = Tt("fixedItemHeight"), r = W("customScrollParent"), s = _e(
+  const e = E.useContext(Re), n = wt("windowViewportRect"), o = wt("fixedItemHeight"), r = W("customScrollParent"), s = _e(
     n,
     r,
     W("skipAnimationFrameInResizeObserver")
   );
-  return H.useEffect(() => {
+  return E.useEffect(() => {
     e && (o(e.itemHeight), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: 100 }));
-  }, [e, n, o]), /* @__PURE__ */ z("div", { "data-viewport-type": "window", ref: s, style: Zt(!1), children: t });
-}, Rr = /* @__PURE__ */ H.memo(function(e) {
-  const n = W("useWindowScroll"), o = W("customScrollParent"), r = Tt("fixedHeaderHeight"), s = Tt("fixedFooterHeight"), i = W("fixedHeaderContent"), l = W("fixedFooterContent"), c = W("context"), a = Ht(
-    H.useMemo(() => ne(r, (u) => wt(u, "height")), [r]),
+  }, [e, n, o]), /* @__PURE__ */ V("div", { "data-viewport-type": "window", ref: s, style: Yt(!1), children: t });
+}, Rr = /* @__PURE__ */ E.memo(function(e) {
+  const n = W("useWindowScroll"), o = W("customScrollParent"), r = wt("fixedHeaderHeight"), s = wt("fixedFooterHeight"), i = W("fixedHeaderContent"), l = W("fixedFooterContent"), c = W("context"), u = Et(
+    E.useMemo(() => te(r, (a) => Rt(a, "height")), [r]),
     !0,
     W("skipAnimationFrameInResizeObserver")
-  ), p = Ht(
-    H.useMemo(() => ne(s, (u) => wt(u, "height")), [s]),
+  ), m = Et(
+    E.useMemo(() => te(s, (a) => Rt(a, "height")), [s]),
     !0,
     W("skipAnimationFrameInResizeObserver")
-  ), S = o || n ? Hr : br, g = o || n ? yr : vr, h = W("TableComponent"), w = W("TableHeadComponent"), v = W("TableFooterComponent"), m = i ? /* @__PURE__ */ z(
+  ), I = o || n ? Hr : br, h = o || n ? yr : vr, p = W("TableComponent"), w = W("TableHeadComponent"), y = W("TableFooterComponent"), f = i ? /* @__PURE__ */ V(
     w,
     {
-      ref: a,
+      ref: u,
       style: { position: "sticky", top: 0, zIndex: 2 },
-      ...q(w, c),
+      ...X(w, c),
       children: i()
     },
     "TableHead"
-  ) : null, d = l ? /* @__PURE__ */ z(
-    v,
+  ) : null, d = l ? /* @__PURE__ */ V(
+    y,
     {
-      ref: p,
+      ref: m,
       style: { bottom: 0, position: "sticky", zIndex: 1 },
-      ...q(v, c),
+      ...X(y, c),
       children: l()
     },
     "TableFoot"
   ) : null;
-  return /* @__PURE__ */ z(S, { ...e, ...q(S, c), children: /* @__PURE__ */ z(g, { children: /* @__PURE__ */ Nt(h, { style: { borderSpacing: 0, overflowAnchor: "none" }, ...q(h, c), children: [
-    m,
-    /* @__PURE__ */ z(wr, {}, "TableBody"),
+  return /* @__PURE__ */ V(I, { ...e, ...X(I, c), children: /* @__PURE__ */ V(h, { children: /* @__PURE__ */ _t(p, { style: { borderSpacing: 0, overflowAnchor: "none" }, ...X(p, c), children: [
+    f,
+    /* @__PURE__ */ V(wr, {}, "TableBody"),
     d
   ] }) }) });
 }), {
   Component: no,
   useEmitter: tn,
   useEmitterValue: W,
-  usePublisher: Tt
+  usePublisher: wt
 } = /* @__PURE__ */ qe(
   Sr,
   {
@@ -2779,7 +2788,7 @@ const dr = ({ children: t }) => {
     }
   },
   Rr
-), br = /* @__PURE__ */ Xe({ useEmitter: tn, useEmitterValue: W, usePublisher: Tt }), Hr = /* @__PURE__ */ Je({ useEmitter: tn, useEmitterValue: W, usePublisher: Tt }), Yr = no, Zr = no, yn = {
+), br = /* @__PURE__ */ Xe({ useEmitter: tn, useEmitterValue: W, usePublisher: wt }), Hr = /* @__PURE__ */ Je({ useEmitter: tn, useEmitterValue: W, usePublisher: wt }), Yr = no, Zr = no, yn = {
   bottom: 0,
   itemHeight: 0,
   items: [],
@@ -2795,7 +2804,7 @@ const dr = ({ children: t }) => {
   offsetBottom: 0,
   offsetTop: 0,
   top: 0
-}, { ceil: Rn, floor: Ce, max: ee, min: Oe, round: bn } = Math;
+}, { ceil: Rn, floor: Te, max: Qt, min: Oe, round: bn } = Math;
 function Hn(t, e, n) {
   return Array.from({ length: e - t + 1 }).map((o, r) => ({ data: n === null ? null : n[r + t], index: r + t }));
 }
@@ -2805,261 +2814,261 @@ function Br(t) {
     items: t
   };
 }
-function he(t, e) {
+function pe(t, e) {
   return t && t.width === e.width && t.height === e.height;
 }
 function kr(t, e) {
   return t && t.column === e.column && t.row === e.row;
 }
-const Fr = /* @__PURE__ */ U(
+const Fr = /* @__PURE__ */ $(
   ([
     { increaseViewportBy: t, listBoundary: e, overscan: n, visibleRange: o },
-    { footerHeight: r, headerHeight: s, scrollBy: i, scrollContainerState: l, scrollTo: c, scrollTop: a, smoothScrollTargetReached: p, viewportHeight: S },
-    g,
+    { footerHeight: r, headerHeight: s, scrollBy: i, scrollContainerState: l, scrollTo: c, scrollTop: u, smoothScrollTargetReached: m, viewportHeight: I },
     h,
-    { didMount: w, propsReady: v },
-    { customScrollParent: m, useWindowScroll: d, windowScrollContainerState: u, windowScrollTo: T, windowViewportRect: R },
-    I
+    p,
+    { didMount: w, propsReady: y },
+    { customScrollParent: f, useWindowScroll: d, windowScrollContainerState: a, windowScrollTo: S, windowViewportRect: R },
+    g
   ]) => {
-    const f = C(0), b = C(0), k = C(yn), F = C({ height: 0, width: 0 }), L = C({ height: 0, width: 0 }), V = $(), D = $(), J = C(0), nt = C(null), B = C({ column: 0, row: 0 }), Y = $(), it = $(), dt = C(!1), St = C(0), ft = C(!0), ut = C(!1), At = C(!1);
-    K(
-      x(
+    const v = C(0), x = C(0), k = C(yn), H = C({ height: 0, width: 0 }), L = C({ height: 0, width: 0 }), z = D(), U = D(), q = C(0), ct = C(null), F = C({ column: 0, row: 0 }), K = D(), tt = D(), ut = C(!1), It = C(0), ft = C(!0), mt = C(!1), kt = C(!1);
+    j(
+      T(
         w,
-        _(St),
-        P(([y, N]) => !!N)
+        _(It),
+        A(([b, N]) => !!N)
       ),
       () => {
         G(ft, !1);
       }
-    ), K(
-      x(
-        rt(w, ft, L, F, St, ut),
-        P(([y, N, Q, lt, , tt]) => y && !N && Q.height !== 0 && lt.height !== 0 && !tt)
+    ), j(
+      T(
+        st(w, ft, L, H, It, mt),
+        A(([b, N, Z, nt, , ot]) => b && !N && Z.height !== 0 && nt.height !== 0 && !ot)
       ),
-      ([, , , , y]) => {
-        G(ut, !0), $e(1, () => {
-          G(V, y);
-        }), bt(x(a), () => {
+      ([, , , , b]) => {
+        G(mt, !0), $e(1, () => {
+          G(z, b);
+        }), vt(T(u), () => {
           G(e, [0, 0]), G(ft, !0);
         });
       }
     ), O(
-      x(
-        it,
-        P((y) => y != null && y.scrollTop > 0),
-        yt(0)
+      T(
+        tt,
+        A((b) => b != null && b.scrollTop > 0),
+        bt(0)
       ),
-      b
-    ), K(
-      x(
+      x
+    ), j(
+      T(
         w,
-        _(it),
-        P(([, y]) => y != null)
+        _(tt),
+        A(([, b]) => b != null)
       ),
-      ([, y]) => {
-        y && (G(F, y.viewport), G(L, y.item), G(B, y.gap), y.scrollTop > 0 && (G(dt, !0), bt(x(a, jt(1)), (N) => {
-          G(dt, !1);
-        }), G(c, { top: y.scrollTop })));
+      ([, b]) => {
+        b && (G(H, b.viewport), G(L, b.item), G(F, b.gap), b.scrollTop > 0 && (G(ut, !0), vt(T(u, Kt(1)), (N) => {
+          G(ut, !1);
+        }), G(c, { top: b.scrollTop })));
       }
     ), O(
-      x(
-        F,
-        E(({ height: y }) => y)
+      T(
+        H,
+        B(({ height: b }) => b)
       ),
-      S
+      I
     ), O(
-      x(
-        rt(
-          A(F, he),
-          A(L, he),
-          A(B, (y, N) => y && y.column === N.column && y.row === N.row),
-          A(a)
+      T(
+        st(
+          P(H, pe),
+          P(L, pe),
+          P(F, (b, N) => b && b.column === N.column && b.row === N.row),
+          P(u)
         ),
-        E(([y, N, Q, lt]) => ({
-          gap: Q,
+        B(([b, N, Z, nt]) => ({
+          gap: Z,
           item: N,
-          scrollTop: lt,
-          viewport: y
+          scrollTop: nt,
+          viewport: b
         }))
       ),
-      Y
+      K
     ), O(
-      x(
-        rt(
-          A(f),
+      T(
+        st(
+          P(v),
           o,
-          A(B, kr),
-          A(L, he),
-          A(F, he),
-          A(nt),
-          A(b),
-          A(dt),
-          A(ft),
-          A(St)
+          P(F, kr),
+          P(L, pe),
+          P(H, pe),
+          P(ct),
+          P(x),
+          P(ut),
+          P(ft),
+          P(It)
         ),
-        P(([, , , , , , , y]) => !y),
-        E(
+        A(([, , , , , , , b]) => !b),
+        B(
           ([
-            y,
-            [N, Q],
-            lt,
-            tt,
-            kt,
-            Jt,
-            $t,
+            b,
+            [N, Z],
+            nt,
+            ot,
+            xt,
+            it,
+            Dt,
             ,
-            de,
+            ae,
             Ft
           ]) => {
-            const { column: Ot, row: Qt } = lt, { height: fe, width: He } = tt, { width: en } = kt;
-            if ($t === 0 && (y === 0 || en === 0))
+            const { column: Ot, row: Xt } = nt, { height: de, width: He } = ot, { width: en } = xt;
+            if (Dt === 0 && (b === 0 || en === 0))
               return yn;
             if (He === 0) {
-              const ln = Ue(Ft, y), io = ln + Math.max($t - 1, 0);
-              return Br(Hn(ln, io, Jt));
+              const ln = Ue(Ft, b), io = ln + Math.max(Dt - 1, 0);
+              return Br(Hn(ln, io, it));
             }
-            const me = oo(en, He, Ot);
-            let Ut, Wt;
-            de ? N === 0 && Q === 0 && $t > 0 ? (Ut = 0, Wt = $t - 1) : (Ut = me * Ce((N + Qt) / (fe + Qt)), Wt = me * Rn((Q + Qt) / (fe + Qt)) - 1, Wt = Oe(y - 1, ee(Wt, me - 1)), Ut = Oe(Wt, ee(0, Ut))) : (Ut = 0, Wt = -1);
-            const nn = Hn(Ut, Wt, Jt), { bottom: on, top: rn } = En(kt, lt, tt, nn), sn = Rn(y / me), so = sn * fe + (sn - 1) * Qt - on;
-            return { bottom: on, itemHeight: fe, items: nn, itemWidth: He, offsetBottom: so, offsetTop: rn, top: rn };
+            const fe = oo(en, He, Ot);
+            let $t, Mt;
+            ae ? N === 0 && Z === 0 && Dt > 0 ? ($t = 0, Mt = Dt - 1) : ($t = fe * Te((N + Xt) / (de + Xt)), Mt = fe * Rn((Z + Xt) / (de + Xt)) - 1, Mt = Oe(b - 1, Qt(Mt, fe - 1)), $t = Oe(Mt, Qt(0, $t))) : ($t = 0, Mt = -1);
+            const nn = Hn($t, Mt, it), { bottom: on, top: rn } = En(xt, nt, ot, nn), sn = Rn(b / fe), so = sn * de + (sn - 1) * Xt - on;
+            return { bottom: on, itemHeight: de, items: nn, itemWidth: He, offsetBottom: so, offsetTop: rn, top: rn };
           }
         )
       ),
       k
     ), O(
-      x(
-        nt,
-        P((y) => y !== null),
-        E((y) => y.length)
+      T(
+        ct,
+        A((b) => b !== null),
+        B((b) => b.length)
       ),
-      f
+      v
     ), O(
-      x(
-        rt(F, L, k, B),
-        P(([y, N, { items: Q }]) => Q.length > 0 && N.height !== 0 && y.height !== 0),
-        E(([y, N, { items: Q }, lt]) => {
-          const { bottom: tt, top: kt } = En(y, lt, N, Q);
-          return [kt, tt];
+      T(
+        st(H, L, k, F),
+        A(([b, N, { items: Z }]) => Z.length > 0 && N.height !== 0 && b.height !== 0),
+        B(([b, N, { items: Z }, nt]) => {
+          const { bottom: ot, top: xt } = En(b, nt, N, Z);
+          return [xt, ot];
         }),
-        Z(se)
+        J(oe)
       ),
       e
     );
-    const xt = C(!1);
+    const St = C(!1);
     O(
-      x(
-        a,
-        _(xt),
-        E(([y, N]) => N || y !== 0)
+      T(
+        u,
+        _(St),
+        B(([b, N]) => N || b !== 0)
       ),
-      xt
+      St
     );
-    const Xt = ht(
-      x(
-        rt(k, f),
-        P(([{ items: y }]) => y.length > 0),
-        _(xt),
-        P(([[y, N], Q]) => {
-          const tt = y.items[y.items.length - 1].index === N - 1;
-          return (Q || y.bottom > 0 && y.itemHeight > 0 && y.offsetBottom === 0 && y.items.length === N) && tt;
+    const Zt = gt(
+      T(
+        st(k, v),
+        A(([{ items: b }]) => b.length > 0),
+        _(St),
+        A(([[b, N], Z]) => {
+          const ot = b.items[b.items.length - 1].index === N - 1;
+          return (Z || b.bottom > 0 && b.itemHeight > 0 && b.offsetBottom === 0 && b.items.length === N) && ot;
         }),
-        E(([[, y]]) => y - 1),
-        Z()
+        B(([[, b]]) => b - 1),
+        J()
       )
-    ), Mt = ht(
-      x(
-        A(k),
-        P(({ items: y }) => y.length > 0 && y[0].index === 0),
-        yt(0),
-        Z()
+    ), be = gt(
+      T(
+        P(k),
+        A(({ items: b }) => b.length > 0 && b[0].index === 0),
+        bt(0),
+        J()
       )
-    ), vt = ht(
-      x(
-        A(k),
-        _(dt),
-        P(([{ items: y }, N]) => y.length > 0 && !N),
-        E(([{ items: y }]) => ({
-          endIndex: y[y.length - 1].index,
-          startIndex: y[0].index
+    ), ue = gt(
+      T(
+        P(k),
+        _(ut),
+        A(([{ items: b }, N]) => b.length > 0 && !N),
+        B(([{ items: b }]) => ({
+          endIndex: b[b.length - 1].index,
+          startIndex: b[0].index
         })),
-        Z(Mn),
+        J(Mn),
         Lt(0)
       )
     );
-    O(vt, h.scrollSeekRangeChanged), O(
-      x(
-        V,
-        _(F, L, f, B),
-        E(([y, N, Q, lt, tt]) => {
-          const kt = Dn(y), { align: Jt, behavior: $t, offset: de } = kt;
-          let Ft = kt.index;
-          Ft === "LAST" && (Ft = lt - 1), Ft = ee(0, Ft, Oe(lt - 1, Ft));
-          let Ot = Ae(N, tt, Q, Ft);
-          return Jt === "end" ? Ot = bn(Ot - N.height + Q.height) : Jt === "center" && (Ot = bn(Ot - N.height / 2 + Q.height / 2)), de && (Ot += de), { behavior: $t, top: Ot };
+    O(ue, p.scrollSeekRangeChanged), O(
+      T(
+        z,
+        _(H, L, v, F),
+        B(([b, N, Z, nt, ot]) => {
+          const xt = Dn(b), { align: it, behavior: Dt, offset: ae } = xt;
+          let Ft = xt.index;
+          Ft === "LAST" && (Ft = nt - 1), Ft = Qt(0, Ft, Oe(nt - 1, Ft));
+          let Ot = Ae(N, ot, Z, Ft);
+          return it === "end" ? Ot = bn(Ot - N.height + Z.height) : it === "center" && (Ot = bn(Ot - N.height / 2 + Z.height / 2)), ae && (Ot += ae), { behavior: Dt, top: Ot };
         })
       ),
       c
     );
-    const Bt = ct(
-      x(
+    const At = at(
+      T(
         k,
-        E((y) => y.offsetBottom + y.bottom)
+        B((b) => b.offsetBottom + b.bottom)
       ),
       0
     );
     return O(
-      x(
+      T(
         R,
-        E((y) => ({ height: y.visibleHeight, width: y.visibleWidth }))
+        B((b) => ({ height: b.visibleHeight, width: b.visibleWidth }))
       ),
-      F
+      H
     ), {
-      customScrollParent: m,
+      customScrollParent: f,
       // input
-      data: nt,
-      deviation: J,
+      data: ct,
+      deviation: q,
       footerHeight: r,
-      gap: B,
+      gap: F,
       headerHeight: s,
       increaseViewportBy: t,
-      initialItemCount: b,
+      initialItemCount: x,
       itemDimensions: L,
       overscan: n,
-      restoreStateFrom: it,
+      restoreStateFrom: tt,
       scrollBy: i,
       scrollContainerState: l,
-      scrollHeight: D,
+      scrollHeight: U,
       scrollTo: c,
-      scrollToIndex: V,
-      scrollTop: a,
-      smoothScrollTargetReached: p,
-      totalCount: f,
+      scrollToIndex: z,
+      scrollTop: u,
+      smoothScrollTargetReached: m,
+      totalCount: v,
       useWindowScroll: d,
-      viewportDimensions: F,
-      windowScrollContainerState: u,
-      windowScrollTo: T,
+      viewportDimensions: H,
+      windowScrollContainerState: a,
+      windowScrollTo: S,
       windowViewportRect: R,
-      ...h,
+      ...p,
       // output
       gridState: k,
-      horizontalDirection: At,
-      initialTopMostItemIndex: St,
-      totalListHeight: Bt,
-      ...g,
-      endReached: Xt,
-      propsReady: v,
-      rangeChanged: vt,
-      startReached: Mt,
-      stateChanged: Y,
-      stateRestoreInProgress: dt,
-      ...I
+      horizontalDirection: kt,
+      initialTopMostItemIndex: It,
+      totalListHeight: At,
+      ...h,
+      endReached: Zt,
+      propsReady: y,
+      rangeChanged: ue,
+      startReached: be,
+      stateChanged: K,
+      stateRestoreInProgress: ut,
+      ...g
     };
   },
-  X(Ke, at, ae, jn, Pt, je, Vt)
+  Q(Ke, dt, ce, jn, Pt, je, Vt)
 );
 function oo(t, e, n) {
-  return ee(1, Ce((t + n) / (Ce(e) + n)));
+  return Qt(1, Te((t + n) / (Te(e) + n)));
 }
 function En(t, e, n, o) {
   const { height: r } = n;
@@ -3069,19 +3078,19 @@ function En(t, e, n, o) {
   return { bottom: Ae(t, e, n, o[o.length - 1].index) + r, top: s };
 }
 function Ae(t, e, n, o) {
-  const r = oo(t.width, n.width, e.column), s = Ce(o / r), i = s * n.height + ee(0, s - 1) * e.row;
+  const r = oo(t.width, n.width, e.column), s = Te(o / r), i = s * n.height + Qt(0, s - 1) * e.row;
   return i > 0 ? i + e.row : i;
 }
-const Or = /* @__PURE__ */ U(() => {
-  const t = C((S) => `Item ${S}`), e = C({}), n = C(null), o = C("virtuoso-grid-item"), r = C("virtuoso-grid-list"), s = C(Ze), i = C("div"), l = C(Yt), c = (S, g = null) => ct(
-    x(
+const Or = /* @__PURE__ */ $(() => {
+  const t = C((I) => `Item ${I}`), e = C({}), n = C(null), o = C("virtuoso-grid-item"), r = C("virtuoso-grid-list"), s = C(Ze), i = C("div"), l = C(qt), c = (I, h = null) => at(
+    T(
       e,
-      E((h) => h[S]),
-      Z()
+      B((p) => p[I]),
+      J()
     ),
-    g
-  ), a = C(!1), p = C(!1);
-  return O(A(p), a), {
+    h
+  ), u = C(!1), m = C(!1);
+  return O(P(m), u), {
     components: e,
     computeItemKey: s,
     context: n,
@@ -3093,97 +3102,97 @@ const Or = /* @__PURE__ */ U(() => {
     itemContent: t,
     listClassName: r,
     ListComponent: c("List", "div"),
-    readyStateChanged: a,
-    reportReadyState: p,
+    readyStateChanged: u,
+    reportReadyState: m,
     ScrollerComponent: c("Scroller", "div"),
     scrollerRef: l,
     ScrollSeekPlaceholder: c("ScrollSeekPlaceholder", "div")
   };
-}), Lr = /* @__PURE__ */ U(
+}), Lr = /* @__PURE__ */ $(
   ([t, e]) => ({ ...t, ...e }),
-  X(Fr, Or)
-), zr = /* @__PURE__ */ H.memo(function() {
-  const e = et("gridState"), n = et("listClassName"), o = et("itemClassName"), r = et("itemContent"), s = et("computeItemKey"), i = et("isSeeking"), l = It("scrollHeight"), c = et("ItemComponent"), a = et("ListComponent"), p = et("ScrollSeekPlaceholder"), S = et("context"), g = It("itemDimensions"), h = It("gap"), w = et("log"), v = et("stateRestoreInProgress"), m = It("reportReadyState"), d = Ht(
-    H.useMemo(
-      () => (u) => {
-        const T = u.parentElement.parentElement.scrollHeight;
-        l(T);
-        const R = u.firstChild;
+  Q(Fr, Or)
+), zr = /* @__PURE__ */ E.memo(function() {
+  const e = et("gridState"), n = et("listClassName"), o = et("itemClassName"), r = et("itemContent"), s = et("computeItemKey"), i = et("isSeeking"), l = Ct("scrollHeight"), c = et("ItemComponent"), u = et("ListComponent"), m = et("ScrollSeekPlaceholder"), I = et("context"), h = Ct("itemDimensions"), p = Ct("gap"), w = et("log"), y = et("stateRestoreInProgress"), f = Ct("reportReadyState"), d = Et(
+    E.useMemo(
+      () => (a) => {
+        const S = a.parentElement.parentElement.scrollHeight;
+        l(S);
+        const R = a.firstChild;
         if (R) {
-          const { height: I, width: f } = R.getBoundingClientRect();
-          g({ height: I, width: f });
+          const { height: g, width: v } = R.getBoundingClientRect();
+          h({ height: g, width: v });
         }
-        h({
-          column: Bn("column-gap", getComputedStyle(u).columnGap, w),
-          row: Bn("row-gap", getComputedStyle(u).rowGap, w)
+        p({
+          column: Bn("column-gap", getComputedStyle(a).columnGap, w),
+          row: Bn("row-gap", getComputedStyle(a).rowGap, w)
         });
       },
-      [l, g, h, w]
+      [l, h, p, w]
     ),
     !0,
     !1
   );
   return Xn(() => {
-    e.itemHeight > 0 && e.itemWidth > 0 && m(!0);
-  }, [e]), v ? null : /* @__PURE__ */ z(
-    a,
+    e.itemHeight > 0 && e.itemWidth > 0 && f(!0);
+  }, [e]), y ? null : /* @__PURE__ */ V(
+    u,
     {
       className: n,
       ref: d,
-      ...q(a, S),
+      ...X(u, I),
       "data-testid": "virtuoso-item-list",
       style: { paddingBottom: e.offsetBottom, paddingTop: e.offsetTop },
-      children: e.items.map((u) => {
-        const T = s(u.index, u.data, S);
-        return i ? /* @__PURE__ */ z(
-          p,
+      children: e.items.map((a) => {
+        const S = s(a.index, a.data, I);
+        return i ? /* @__PURE__ */ V(
+          m,
           {
-            ...q(p, S),
+            ...X(m, I),
             height: e.itemHeight,
-            index: u.index,
+            index: a.index,
             width: e.itemWidth
           },
-          T
-        ) : /* @__PURE__ */ _t(
+          S
+        ) : /* @__PURE__ */ Gt(
           c,
           {
-            ...q(c, S),
+            ...X(c, I),
             className: o,
-            "data-index": u.index,
-            key: T
+            "data-index": a.index,
+            key: S
           },
-          r(u.index, u.data, S)
+          r(a.index, a.data, I)
         );
       })
     }
   );
-}), Vr = H.memo(function() {
-  const e = et("HeaderComponent"), n = It("headerHeight"), o = et("headerFooterTag"), r = Ht(
-    H.useMemo(
+}), Vr = E.memo(function() {
+  const e = et("HeaderComponent"), n = Ct("headerHeight"), o = et("headerFooterTag"), r = Et(
+    E.useMemo(
       () => (i) => {
-        n(wt(i, "height"));
+        n(Rt(i, "height"));
       },
       [n]
     ),
     !0,
     !1
   ), s = et("context");
-  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...q(e, s) }) }) : null;
-}), Pr = H.memo(function() {
-  const e = et("FooterComponent"), n = It("footerHeight"), o = et("headerFooterTag"), r = Ht(
-    H.useMemo(
+  return e ? /* @__PURE__ */ V(o, { ref: r, children: /* @__PURE__ */ V(e, { ...X(e, s) }) }) : null;
+}), Pr = E.memo(function() {
+  const e = et("FooterComponent"), n = Ct("footerHeight"), o = et("headerFooterTag"), r = Et(
+    E.useMemo(
       () => (i) => {
-        n(wt(i, "height"));
+        n(Rt(i, "height"));
       },
       [n]
     ),
     !0,
     !1
   ), s = et("context");
-  return e ? /* @__PURE__ */ z(o, { ref: r, children: /* @__PURE__ */ z(e, { ...q(e, s) }) }) : null;
+  return e ? /* @__PURE__ */ V(o, { ref: r, children: /* @__PURE__ */ V(e, { ...X(e, s) }) }) : null;
 }), Ar = ({ children: t }) => {
-  const e = H.useContext(Zn), n = It("itemDimensions"), o = It("viewportDimensions"), r = Ht(
-    H.useMemo(
+  const e = E.useContext(Zn), n = Ct("itemDimensions"), o = Ct("viewportDimensions"), r = Et(
+    E.useMemo(
       () => (s) => {
         o(s.getBoundingClientRect());
       },
@@ -3192,26 +3201,26 @@ const Or = /* @__PURE__ */ U(() => {
     !0,
     !1
   );
-  return H.useEffect(() => {
+  return E.useEffect(() => {
     e && (o({ height: e.viewportHeight, width: e.viewportWidth }), n({ height: e.itemHeight, width: e.itemWidth }));
-  }, [e, o, n]), /* @__PURE__ */ z("div", { ref: r, style: Zt(!1), children: t });
+  }, [e, o, n]), /* @__PURE__ */ V("div", { ref: r, style: Yt(!1), children: t });
 }, Mr = ({ children: t }) => {
-  const e = H.useContext(Zn), n = It("windowViewportRect"), o = It("itemDimensions"), r = et("customScrollParent"), s = _e(n, r, !1);
-  return H.useEffect(() => {
+  const e = E.useContext(Zn), n = Ct("windowViewportRect"), o = Ct("itemDimensions"), r = et("customScrollParent"), s = _e(n, r, !1);
+  return E.useEffect(() => {
     e && (o({ height: e.itemHeight, width: e.itemWidth }), n({ offsetTop: 0, visibleHeight: e.viewportHeight, visibleWidth: e.viewportWidth }));
-  }, [e, n, o]), /* @__PURE__ */ z("div", { ref: s, style: Zt(!1), children: t });
-}, Wr = /* @__PURE__ */ H.memo(function({ ...e }) {
+  }, [e, n, o]), /* @__PURE__ */ V("div", { ref: s, style: Yt(!1), children: t });
+}, Wr = /* @__PURE__ */ E.memo(function({ ...e }) {
   const n = et("useWindowScroll"), o = et("customScrollParent"), r = o || n ? Nr : _r, s = o || n ? Mr : Ar, i = et("context");
-  return /* @__PURE__ */ z(r, { ...e, ...q(r, i), children: /* @__PURE__ */ Nt(s, { children: [
-    /* @__PURE__ */ z(Vr, {}),
-    /* @__PURE__ */ z(zr, {}),
-    /* @__PURE__ */ z(Pr, {})
+  return /* @__PURE__ */ V(r, { ...e, ...X(r, i), children: /* @__PURE__ */ _t(s, { children: [
+    /* @__PURE__ */ V(Vr, {}),
+    /* @__PURE__ */ V(zr, {}),
+    /* @__PURE__ */ V(Pr, {})
   ] }) });
 }), {
   Component: Gr,
   useEmitter: ro,
   useEmitterValue: et,
-  usePublisher: It
+  usePublisher: Ct
 } = /* @__PURE__ */ qe(
   Lr,
   {
@@ -3253,18 +3262,18 @@ const Or = /* @__PURE__ */ U(() => {
     }
   },
   Wr
-), _r = /* @__PURE__ */ Xe({ useEmitter: ro, useEmitterValue: et, usePublisher: It }), Nr = /* @__PURE__ */ Je({ useEmitter: ro, useEmitterValue: et, usePublisher: It });
+), _r = /* @__PURE__ */ Xe({ useEmitter: ro, useEmitterValue: et, usePublisher: Ct }), Nr = /* @__PURE__ */ Je({ useEmitter: ro, useEmitterValue: et, usePublisher: Ct });
 function Bn(t, e, n) {
-  return e !== "normal" && !(e != null && e.endsWith("px")) && n(`${t} was not resolved to pixel value correctly`, e, mt.WARN), e === "normal" ? 0 : parseInt(e != null ? e : "0", 10);
+  return e !== "normal" && !(e != null && e.endsWith("px")) && n(`${t} was not resolved to pixel value correctly`, e, pt.WARN), e === "normal" ? 0 : parseInt(e != null ? e : "0", 10);
 }
 const Xr = Gr;
 export {
   Zr as GroupedTableVirtuoso,
   qr as GroupedVirtuoso,
-  mt as LogLevel,
+  pt as LogLevel,
   Yr as TableVirtuoso,
   jr as Virtuoso,
   Xr as VirtuosoGrid,
   Zn as VirtuosoGridMockContext,
-  be as VirtuosoMockContext
+  Re as VirtuosoMockContext
 };
